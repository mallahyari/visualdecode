"use strict";(self.webpackChunkvisdecode_site=self.webpackChunkvisdecode_site||[]).push([[7606],{8794:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"visualizing-weather-types-and-trends","metadata":{"permalink":"/visualdecode/blog/visualizing-weather-types-and-trends","source":"@site/blog/2023-02-03-weather-data-with-radarplot.md","title":"A Clear Picture: Visualizing Weather Types and Trends","description":"\x3c!-- import TOCInline from \'@theme/TOCInline\';","date":"2023-02-03T00:00:00.000Z","formattedDate":"February 3, 2023","tags":[{"label":"weather data","permalink":"/visualdecode/blog/tags/weather-data"},{"label":"data visualization","permalink":"/visualdecode/blog/tags/data-visualization"},{"label":"radar plot","permalink":"/visualdecode/blog/tags/radar-plot"}],"readingTime":12.04,"hasTruncateMarker":true,"authors":[{"name":"Mehdi Allahyari","title":"Principle Research Scientist","url":"https://github.com/mallahyari","imageURL":"https://github.com/mallahyari.png","key":"mehdi"}],"frontMatter":{"slug":"visualizing-weather-types-and-trends","title":"A Clear Picture: Visualizing Weather Types and Trends","authors":["mehdi"],"tags":["weather data","data visualization","radar plot"],"hide_table_of_contents":false,"toc_min_heading_level":2,"toc_max_heading_level":5},"nextItem":{"title":"Designing Eye-catching Radar Plots with React and D3","permalink":"/visualdecode/blog/beautiful-radar-plot"}},"content":"\x3c!-- import TOCInline from \'@theme/TOCInline\';\\n\\n<details>\\n<summary> Table of Contents</summary>\\n\\n<TOCInline toc={toc} />\\n</details> --\x3e\\n\\n## Introduction\\n\\nWeather has a significant impact on our daily lives, from deciding what to wear to planning outdoor activities. Understanding weather patterns and trends can be crucial in making informed decisions. In this blog post, we will explore a weather dataset and create visualizations to better understand the types of weather and their trends over time.\\nThe original idea came to my mind while I was reading an article ([Practice perfect](https://www.theplot.media/p/practice)) of the [The Plot](https://www.theplot.media/) newsletter. The article was about describing whatever you\'re trying to show clearly in one sentence. The author created a visualization illustrating her fitness routine in 2022. The visualization caught my eyes instantaneously as it was quite beautiful. I got inspired by that and decided to create a similar visualization. However, I didn\'t have fitness data, therefore I chose weather data instead.\\n\\n\x3c!--truncate--\x3e\\n\\nThe dataset used in this project is part of a bigger weather dataset that I originally downloaded from [here](https://github.com/vega/vega/blob/main/docs/data/seattle-weather.csv) and contains information about the minimum and maximum temperatures, wind, and the type of weather for a specific location and time period. Using this data, we will create a radar plot that provides a clear picture of the weather patterns and trends. The radar plot is an ideal choice for this type of data as it allows us to visualize multiple variables in a single graph and compare them effectively.\\n\\nimport Figure from \'@site/src/components/Figure\'\\n\\n<Figure imageSrc=\'weather-radar-plot.png\' caption=\'Final visualization of weather dataset\' />\\n\\nWe will need to start by setting up the React project (_I will skip this part because I have already covered it in my previous posts_), importing the data, and creating the radar plot using D3, . Then, we will add additional features to the radar plot to provide more context and insights into the data. By the end of this post, you will have a better understanding of how to use React and D3 to visualize weather data and gain insights into its trends and patterns.\\n\\n## Importing the Weather Data\\n\\nWith the React project set up, you can now import the weather dataset. You can use JavaScript\'s built-in fetch API or a library like Axios to retrieve the data from a server or a local file. I created a Github Gist [here](https://gist.github.com/mallahyari/1e0a70ed89e553ecf2db7e24a9b91d65) and uploaded the file, so we can directly download and read the file in our project. We can use Fetch API or `d3.csv()` method to read the file.\\n\\n```javascript\\nimport { csv } from \'d3\';\\n\\nexport const useWeatherData = () => {\\n  const [data, setData] = useState();\\n  useEffect(() => {\\n    csv(\\n      \'https://gist.githubusercontent.com/mallahyari/1e0a70ed89e553ecf2db7e24a9b91d65/raw/02d48c2d42515dd892c41cca13c34cc1d0c09ebe/weather_fake_data.csv\'\\n    ).then((dataset) => setData(dataset));\\n  }, []);\\n\\n  return data;\\n};\\n```\\n\\n## Preparing the Data for Visualization\\n\\nAfter importing the data, you\'ll need to clean and prepare it for visualization. This may involve removing any missing values, converting data types, or aggregating the data. One of the visual data elements that I will draw is different weather types. Therefore, I needed to aggregate the data (group by) `weather` column, that you will see in the later section. You can see a snippet of the dataset including its columns:\\n\\n![weather dataset](/img/weather_dataset.png)\\n\\n## Code Explanation for Creating the Radar Plot with D3 and React\\n\\nThe first step in creating the radar plot is to set up the D3 scales and axes. The scales will be used to map the data values to the chart, and the axes will be used to define the boundaries of the chart. I defined a `WeatherPlot.js` file and added my component.\\n\\n```javascript\\n// import necessary modules\\n\\nconst dimensions = {\\n  width: 1100,\\n  height: 1100,\\n  margin: { top: 50, right: 60, bottom: 50, left: 60 },\\n};\\n\\nexport const WeatherPlot = () => {\\n  const { width, height, margin } = dimensions;\\n  const boundedDimensions = {\\n    width: dimensions.width - margin.left - margin.right,\\n    height: dimensions.height - margin.top - margin.bottom,\\n  };\\n  const boundedRadius = boundedDimensions.width / 2;\\n  const outerRadius = (boundedDimensions.width / 2) * 0.5;\\n  const innerRadius = outerRadius / 3;\\n\\n  return (\\n    <div>\\n      <svg\\n        width={width}\\n        height={height}\\n        style={{ backgroundColor: \'#000\' }}\\n      ></svg>\\n    </div>\\n  );\\n};\\n```\\n\\n### Creating the Scales\\n\\nIf you look at the data, it shows one year of data with other features. We are going to show temperatures over time, so we need two scales. One scale for _date_ and another one for _temperature_. The scale for date transforms dates into angles and other scale maps temperature numbers into distance from the center of the circle or the plot. I define my scales as follows:\\n\\n````javascript\\n// Create angle scale for mapping the dates to angles\\n  const angleScale = d3\\n    .scaleTime()\\n    .domain(d3.extent(data, dateAccessor))\\n    .range([0, 2 * Math.PI]);\\n\\n  // Create radius scale for mapping min and max temperatures to distances\\n  const radiusScale = d3\\n    .scaleLinear()\\n    .domain(\\n      d3.extent([...data.map(tempMinAccessor), ...data.map(tempMaxAccessor)])\\n    )\\n    .range([innerRadius, outerRadius])\\n    .nice();\\n    ```\\n````\\n\\nThe domain of `angleScale` is the range of `[min date, max date]` and range is the entire circle, which is `[0, 2 * Math.PI]`. For my `radiusScale`, the domain and range will be `[min temperature, max temperature]` and `[inner radius. outer radius]`, respectively.\\n\\n<Figure imageSrc=\'weather_radar_circles.png\' />\\n\\n### Creating Grid Lines and Ticks\\n\\nLet\'s create a grid line for each month and also create text labels of months. We need a function to covert angle to `[x, y]` point to be able to draw grid lines. Also, we need names of months. We can define an array with months names, however, instead of hardcoding, let\'s get them from our angle scale domain using `d3.timeMonths()` function.\\n\\n```javascript\\n// Define month names for creating text labels on the plot\\nconst months = d3.timeMonths(...angleScale.domain());\\n\\n// Define a function to convert angle into position\\nconst getCoordinatesForAngle = (angle, radius, offset = 1) => {\\n  return d3.pointRadial(angle, radius * offset);\\n};\\n```\\n\\nNow that we have what we need, let\'s draw the grid lines with labels.\\n\\n```javascript\\n{\\n  months.map((m, i) => {\\n    const angle = angleScale(m);\\n    const angleOffset = Math.PI / 12;\\n    const [x1, y1] = getCoordinatesForAngle(angle, innerRadius);\\n    const [x2, y2] = getCoordinatesForAngle(angle, outerRadius, 1.01);\\n    const [labelX, labelY] = getCoordinatesForAngle(\\n      angle + angleOffset,\\n      outerRadius,\\n      1.05\\n    );\\n    return (\\n      <g key={i}>\\n        <line\\n          x1={x1}\\n          y1={y1}\\n          x2={x2}\\n          y2={y2}\\n          strokeWidth={2}\\n          className=\\"grid-line\\"\\n        />\\n        <text x={labelX} y={labelY} textAnchor=\\"middle\\" className=\\"tick-label\\">\\n          {d3.timeFormat(\'%B\')(m)}\\n        </text>\\n      </g>\\n    );\\n  });\\n}\\n```\\n\\nHere\'s the output plot:\\n\\n![radar-gridlines](/img/weather_radar_gridlines.png)\\n\\nIt\'s pretty cool, isn\'t it? ;)\\n\\nAlthough text labels look nice, but instead of being horizontal, I would like them to rotate around the circle. Therefore, I need to use `<textPath>`, it allows us to render text along the shape of a `<path>`. Please check [this link](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/textPath) for complete description and examples.\\n\\nNevertheless, the idea is I have to create an `arc` shape path and then render my text label using that path. I need to create arc path between each two consecutive months, and then draw my text label along that path.\\n\\n<Figure imageSrc=\'weather-textpath.png\' caption=\\"Example of <textPath>\\" />\\n\\nTo be able to get month intervals, I will use [d3.utcMonth.offset(date[, step])](https://github.com/d3/d3-time/blob/main/README.md).\\n\\n```javascript\\nconst monthsTextPath = months.map((d) => [d, d3.utcMonth.offset(d, 1)]);\\n```\\n\\nLet\'s replace the months text labels generated before with these new ones.\\n\\n```javascript\\n{\\n  monthsTextPath.slice(0, 1).map(([a, b], i) => {\\n    const id = `month-path-${i}`;\\n    const angleA = angleScale(a);\\n    const angleB = angleScale(b);\\n    const movePoint = getCoordinatesForAngle(angleA, outerRadius);\\n    const arcPoint = getCoordinatesForAngle(angleB, outerRadius);\\n\\n    return (\\n      <g key={`g-${i}`}>\\n        <path\\n          key={id}\\n          id={id}\\n          d={`\\n            M${movePoint} \\n            A${outerRadius},${outerRadius} 0,0,1 ${arcPoint}`}\\n          stroke=\\"tomato\\"\\n        />\\n        <text\\n          key={`month-textPath-${i}`}\\n          textAnchor=\\"middle\\"\\n          className=\\"tick-label\\"\\n        >\\n          <textPath startOffset=\\"50%\\" href={`#${id}`}>\\n            {d3.utcFormat(\'%B\')(a)}\\n          </textPath>\\n        </text>\\n      </g>\\n    );\\n  });\\n}\\n```\\n\\nHere\'s the result:\\n\\n<Figure imageSrc=\'weather-textpath-final.png\'  />\\n\\nNext step is to create ticks for our plot, which is easily done via our `radiusScale.ticks()` function.\\n\\n```javascript\\n// Define ticks for our plot\\nconst tempTicks = radiusScale.ticks(5);\\n```\\n\\nI use the ticks to draw tick values and circles.\\n\\n```javascript\\n{\\n  tempTicks.map((t, i) => (\\n    <g key={i}>\\n      <circle r={radiusScale(t)} className=\\"grid-line\\" />\\n      <rect x={5} y={-radiusScale(t) - 10} width={30} height={20} fill=\\"#000\\" />\\n      <text x={6} y={-radiusScale(t) + 5} className=\\"tick-label-temperature\\">\\n        {`${d3.format(\'.0f\')(t)}\\\\u00b0F`}\\n      </text>\\n    </g>\\n  ));\\n}\\n```\\n\\nLet\'s see the outcome:\\n\\n![weather radar ticks](/img/weather-radar-ticks.png)\\n\\n### Drawing the Area Radial\\n\\nWe need `d3.areaRadial()` to draw the actual plot. It requires `angle()`, `innerRadius()` and `outerRadius()` to be set. By setting them and passing the dataset it generates the `<path>` for us.\\n\\n```javascript\\n// Define generators for shape of the plot\\nconst areaGenerator = d3\\n  .areaRadial()\\n  .angle((d) => angleScale(dateAccessor(d)))\\n  .innerRadius((d) => radiusScale(tempMinAccessor(d)))\\n  .outerRadius((d) => radiusScale(tempMaxAccessor(d)));\\n\\n// inside SVG tag\\n<path d={areaGenerator(data)} fill=\\"tomato\\" className=\\"area\\" />;\\n```\\n\\n![radar plot v1](/img/weather-radar-v1.png)\\n\\nWe can draw a line on the outer side or inner side of plot to make it stand out more. The code below will draw on the outer side of the plot, you can change the `lineOuterRadius()` to `lineInnerRadius()` to draw inner line, or draw both if you like. It can be easily achieved in two ways.\\n\\n```javascript\\n// Select METHOD 1 OR METHOD 2\\n// METHOD 1\\nconst lineGenerator = areaGenerator.lineOuterRadius();\\n\\n// METHOD 2\\nconst lineGenerator = d3\\n  .lineRadial()\\n  .curve(d3.curveCardinal)\\n  .angle((d) => angleScale(dateAccessor(d)))\\n  .radius((d) => radiusScale(tempMaxAccessor(d)));\\n\\n// In SVG tag\\n<path\\n  d={lineGenerator(data)}\\n  fill=\\"none\\"\\n  stroke=\\"#f8f9fa\\"\\n  className=\\"line-radial\\"\\n/>;\\n```\\n\\n<Figure imageSrc=\'weather-radar-v2.png\' caption=\\"Radar plot with outer line\\"  />\\n\\n### Changing the Color using RadialGradient\\n\\nI\'d like to change the color of the plot and use a gradient color instead to make it look even better. `<radialGradient>` is the right choice because our plot is a radial plot. You can read its [documentation](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/radialGradient) to learn more about different gradients.\\n\\nThe important attributes are `id`, `offset` and `stop-color`. We can define our `<radialGradient>` in the `<def>` tag. The `<def>` tag job is to store graphical objects that will be used later again. You can think of it as browser `localStorage`.\\n\\n```javascript\\n<defs>\\n  <radialGradient id=\\"temp-gradient\\">\\n    {d3.range(numOfStops).map((i) => (\\n      <stop\\n        key={i}\\n        offset={`${(i / (numOfStops - 1)) * 100}%`}\\n        stopColor={gradientColorScale(i / (numOfStops - 1))}\\n      />\\n    ))}\\n  </radialGradient>\\n</defs>\\n```\\n\\nTo select a gradient color, I am going to use one of d3 [color schemes](https://observablehq.com/@d3/color-schemes)\\n\\n```javascript\\n// Create gradient color for area path\\nconst gradientColorScale = d3.interpolateBrBG;\\n```\\n\\nNow I\'ll update my area path `fill` attribute to use my gradient color.\\n\\n```javascript\\n<path d={areaGenerator(data)} fill={`url(#temp-gradient)`} className=\\"area\\" />\\n```\\n\\n<Figure imageSrc=\'weather-radar-radial-gradient.png\' caption=\\"Radar plot with radial gradient\\"  />\\n\\n### Drawing Weather Types\\n\\nAwesome! We\'re done with main radar plot. However, I would like to draw weather types and the wind speed attributes into this plot as well.\\n\\nWe need to _transform_ out data, i.e. _group_ the data by various weather types. Additionally, I define `offset` values for each type, so we can draw them at different distances to prevent overlap.\\n\\n```javascript\\n// Group by the data based on `weather` types\\nconst dataGroupedByWeather = d3.group(data, (d) => d.weather);\\n\\n// Create offsets to easily draw circles with certain offset of the main radius.\\nconst weatherTypes = Array.from(dataGroupedByWeather.keys());\\nconst weatherTypeOffsets = weatherTypes.map((t, i) => ({\\n  type: t,\\n  offset: 1.18 + i * 0.1,\\n}));\\n\\nconst windOffset = 1.7;\\n```\\n\\nI also define another scale to be able to change the size of the `<circle>` elements based on the wind speed. The higher the speed, the bigger the circle. However, the _size_ of the circle and its _radius_ grow at different rates. What I mean is that if we multiply the radius of a circle by 2, its area becomes 4 times larger.\\n\\n$$area_{c_1} = \\\\pi {r_1}^2$$\\n\\n$$r_2= 2r_1 \\\\Rightarrow area_{c_2} = \\\\pi ({2r_1})^2 = 4\\\\pi {r_1}^2$$\\n\\n$$\\\\frac{area_{c_2}}{area_{c_1}} = 4$$\\n\\nSo what is the ratio or radius to the area of a circle?!\\n\\n$$r=\\\\sqrt{\\\\frac{area}{\\\\pi}} \\\\Rightarrow r \\\\propto \\\\sqrt{area}$$\\n\\nTherefore, we\'d rather use [d3.scaleSqrt()](https://github.com/d3/d3-scale#scaleSqrt) instead of a _linear_ scale.\\n\\n```javascript\\n// Create radius scale for wind numbers\\nconst windRadiusScale = d3\\n  .scaleSqrt()\\n  .domain(d3.extent(data, windAccessor))\\n  .range([2, 10]);\\n```\\n\\nI considered the range (i.e. radii of the circles) to be `[2, 10]`. I need five distinctive colors for weather types, so I used discrete colors:\\n\\n```javascript\\n// Define colors for color coding different types of weather\\nconst weatherColors = d3.schemeRdYlGn[5];\\n```\\n\\nPutting together all the pieces, we will have:\\n\\n```javascript\\n{\\n  weatherTypes.map((wt, i) =>\\n    dataGroupedByWeather.get(wt).map((d, j) => {\\n      const angle = angleScale(dateAccessor(d));\\n      const [x, y] = getCoordinatesForAngle(\\n        angle,\\n        outerRadius,\\n        weatherTypeOffsets[i].offset\\n      );\\n\\n      return (\\n        <g key={`${wt}-${i}${j}`}>\\n          <circle\\n            cx={x}\\n            cy={y}\\n            r={5}\\n            fill={weatherColors[i]}\\n            className={`${wt}-circle`}\\n          />\\n        </g>\\n      );\\n    })\\n  );\\n}\\n\\n{\\n  data.map((d, i) => {\\n    const angle = angleScale(dateAccessor(d));\\n    const [x, y] = getCoordinatesForAngle(angle, outerRadius, windOffset);\\n\\n    return (\\n      <g key={`wind-${i}`}>\\n        <circle\\n          cx={x}\\n          cy={y}\\n          r={windRadiusScale(windAccessor(d))}\\n          className={`wind-circle`}\\n        />\\n      </g>\\n    );\\n  });\\n}\\n```\\n\\nAnd our plot looks like this:\\n\\n<Figure imageSrc=\'weather-radar-v3.png\' caption=\\"Radar plot with weather types\\"  />\\n\\n### Adding Annotations to the Plot\\n\\nWe\'re almost done. The only thing left out is to annotate our plot, so if someone looks at our plot they can easily figure out all the information it\'s offering.\\nTo put it into simple words, annotation is essentially, some textual content along with some line to guide the text. Therefore, we need to draw some `<text>` and `<line>` elements.\\n\\nBecause we need several annotations, i.e. drawing several `<line>` and `<text>` elements, I defined a function to make it straightforward. This function input will be `angle`, `offset` and `text` and returns an object having `x` and `y` positions and `text` for drawing line and text.\\n\\n```javascript\\n// Define a function for creating text annotations on the plot\\nconst drawAnnotation = (angle, offset, text) => {\\n  const [x1, y1] = getCoordinatesForAngle(angle, outerRadius, offset);\\n  const [x2, y2] = getCoordinatesForAngle(angle, outerRadius, 2);\\n\\n  return { x1, x2, y1, y2, text };\\n};\\n```\\n\\nLet\'s create our annotations:\\n\\n```javascript\\n// Define annotation for various type of information\\nconst sunAnnotation = drawAnnotation(\\n  Math.PI * 0.21,\\n  weatherTypeOffsets.find((el) => el.type === \'sun\')[\'offset\'],\\n  \'Sunny days\'\\n);\\nconst rainAnnotation = drawAnnotation(\\n  Math.PI * 0.3,\\n  weatherTypeOffsets.find((el) => el.type === \'rain\')[\'offset\'],\\n  \'Rainy days\'\\n);\\nconst snowAnnotation = drawAnnotation(\\n  Math.PI * 0.05,\\n  weatherTypeOffsets.find((el) => el.type === \'snow\')[\'offset\'],\\n  \'Snowy days\'\\n);\\nconst drizzleAnnotation = drawAnnotation(\\n  Math.PI * 0.25,\\n  weatherTypeOffsets.find((el) => el.type === \'drizzle\')[\'offset\'],\\n  \'Drizzly days\'\\n);\\nconst fogAnnotation = drawAnnotation(\\n  Math.PI * 0.367,\\n  weatherTypeOffsets.find((el) => el.type === \'fog\')[\'offset\'],\\n  \'foggy days\'\\n);\\nconst windAnnotation = drawAnnotation(Math.PI * 0.15, windOffset, \'Wind\');\\n```\\n\\nI then created a React component called `Annotation`, which basically draws the line and text, given the annotation data.\\n\\n```javascript\\nconst Annotaion = ({ annotationData }) => (\\n  <g>\\n    <line\\n      x1={annotationData.x1}\\n      x2={annotationData.x2}\\n      y1={annotationData.y1}\\n      y2={annotationData.y2 + 10}\\n      className=\\"annotation-line\\"\\n    />\\n    <text\\n      x={annotationData.x2 + 5}\\n      y={annotationData.y2 + 10}\\n      className=\\"annotation-text\\"\\n    >\\n      {annotationData.text}\\n    </text>\\n  </g>\\n);\\n```\\n\\nAnd we\'re done! Here\'s the final plot:\\n\\n<Figure imageSrc=\'weather-radar-final.png\' caption=\\"Radar plot final version\\"  />\\n\\nYou can find all the code at [this repo](https://github.com/mallahyari/vis-react-d3) along with previous posts\' code.\\n\\nThank you for reading this blog. You can follow me on [Linkedin](https://www.linkedin.com/in/mehdiallahyari/) or [Twitter](https://twitter.com/MehdiAllahyari), and please reach out if you have any comments, or interested in any custom visualization."},{"id":"beautiful-radar-plot","metadata":{"permalink":"/visualdecode/blog/beautiful-radar-plot","source":"@site/blog/2023-01-26-simple-radarplot.md","title":"Designing Eye-catching Radar Plots with React and D3","description":"\x3c!--","date":"2023-01-26T00:00:00.000Z","formattedDate":"January 26, 2023","tags":[{"label":"data visualization","permalink":"/visualdecode/blog/tags/data-visualization"},{"label":"radar plot","permalink":"/visualdecode/blog/tags/radar-plot"},{"label":"react","permalink":"/visualdecode/blog/tags/react"},{"label":"d3","permalink":"/visualdecode/blog/tags/d-3"}],"readingTime":9.085,"hasTruncateMarker":true,"authors":[{"name":"Mehdi Allahyari","title":"Principle Research Scientist","url":"https://github.com/mallahyari","imageURL":"https://github.com/mallahyari.png","key":"mehdi"}],"frontMatter":{"slug":"beautiful-radar-plot","title":"Designing Eye-catching Radar Plots with React and D3","authors":["mehdi"],"tags":["data visualization","radar plot","react","d3"],"hide_table_of_contents":false,"toc_min_heading_level":2,"toc_max_heading_level":5},"prevItem":{"title":"A Clear Picture: Visualizing Weather Types and Trends","permalink":"/visualdecode/blog/visualizing-weather-types-and-trends"},"nextItem":{"title":"How to add a tooltip to a line chart","permalink":"/visualdecode/blog/add-tooltip"}},"content":"\x3c!--\\nimport TOCInline from \'@theme/TOCInline\';\\n\\n<details>\\n<summary> Table of Contents</summary>\\n\\n<TOCInline toc={toc} />\\n</details> --\x3e\\n\\n## Introduction\\n\\nRadar plots, also known as spider plots or star plots, are a great way to visualize multivariate data. They are particularly useful when you want to compare multiple variables for a set of items. Here are some situations where radar plots may be useful:\\n\\n\x3c!--truncate--\x3e\\n\\n- _Comparing multiple variables:_ Radar plots are useful for showing how multiple variables are related to each other. They allow you to see the relative strengths and weaknesses of each variable across a set of items.\\n- _Showing relative values:_ Radar plots can be useful for showing the relative values of each variable for a set of items. This can be useful for comparing the relative strengths and weaknesses of different items.\\n\\n- _Displaying data with cyclical patterns:_ If your data has cyclical patterns, such as seasonal patterns, a radar plot can help you visualize it by plotting the variables on a circular axis.\\n\\nRadar plots tend to be among my favorite types of plots as they can convey various kinds of information simultaneously, and are also visually appealing. In this blog post, I will show you how to create a radar plot using React and D3.js. Like previous blogs, our goal is to use React for managing the DOM and utilize d3 for data manipulations.\\n\\nThere are many libraries that allow you to draw radar plots like [Plotly](https://plotly.com/python/radar-chart/), but when it comes to creating _beautiful_ plots, they are limited and don\'t have a lot of flexibility. That make sense, because their intention is more towards non-technical individuals.\\n\\nPlots do not have to be _necessarily_ visually appealing, but it is generally beneficial for them to be clear and easy to understand. A well-designed plot can help make the data more accessible and easier to interpret. This can be especially important when presenting data to non-experts or decision-makers who may not have the same level of expertise in the subject matter.\\n\\nVisual appeal can be achieved by using colors, labels, and other design elements to guide the viewer\'s eye through the data. This can help convey the main message of the plot more effectively. It is also important to choose the right type of plot for the data and the message you want to convey.\\n\\nI covered in the [visualizing line chart](./2023-01-15-linechart.md) that for creating any plot we need to follow six main steps:\\n\\n1. Prepare the data\\n2. Create the SVG element\\n3. Create the scales\\n4. Draw the (radar) plot\\n5. Add interactivity\\n6. Add styling\\n\\nNow let\'s complete each step.\\n\\n## Prepare the data\\n\\nBefore we are able to proceed, we need to prepare our dataset. For this example I have created some fake data. My data represents levels of skills for two persons.\\n\\n```javascript\\nconst initialData = [\\n  [\\n    { key: \'resilience\', value: 19 },\\n    { key: \'strength\', value: 6 },\\n    { key: \'adaptability\', value: 20 },\\n    { key: \'creativity\', value: 12 },\\n    { key: \'openness\', value: 1 },\\n    { key: \'confidence\', value: 11 },\\n  ],\\n  [\\n    { key: \'resilience\', value: 7 },\\n    { key: \'strength\', value: 18 },\\n    { key: \'adaptability\', value: 6 },\\n    { key: \'creativity\', value: 14 },\\n    { key: \'openness\', value: 17 },\\n    { key: \'confidence\', value: 14 },\\n  ],\\n];\\n```\\n\\n## Create the SVG element\\n\\nI create a file called `SimpleRadar.js` as my React component, and add an SVG element that will be used to render the radar plot. We need to define dimensions of our SVG.\\n\\n```javascript\\nconst dimensions = {\\n  width: 600,\\n  height: 600,\\n  margin: { top: 50, right: 60, bottom: 50, left: 60 },\\n};\\n\\nconst SimpleRadar = ({ data = initialData }) => {\\n  const { width, height, margin } = dimensions;\\n\\n  // bounding box dimensions\\n  const boundedDimensions = {\\n    width: dimensions.width - margin.left - margin.right,\\n    height: dimensions.height - margin.top - margin.bottom,\\n  };\\n\\n  boundedDimensions.radius = boundedDimensions.width / 2;\\n\\n  return (\\n    <div>\\n      <svg width={width} height={height}></svg>\\n    </div>\\n  );\\n};\\n```\\n\\nWe would like our radar plot to be in the center of the SVG, therefore, we\'d set our SVG `width` and `height` to be equal. The _bounding box_ that we create inside SVG, which basically contain all the data visualization elements must respect our SVG margins, to make sure the entire chart will displayed properly. Thus, we shift our bounding box so that `(0, 0)` point will be top-left of the bounding box. The figure below depicts the transformation.\\n\\n![grid line](/img/radar_svg_boundingbox.png)\\n\\nHowever, we will have some difficulties. Our radar chart is expected to be inside the bounding box, to be in the center of it to be exact. Therefore, selecting top-left of the bounding box as our `(0, 0)` point makes our math and all the calculations that we need to do for drawing circles, ticks, axes, etc., more difficult. Because all the drawings will be in respect to this point. _To make our math much easier later on_, we shift our bounding box in such a way that the point `(0, 0)` will shift to the center of the SVG. Now, we can place our visualization elements easily with respect to the center of radar plot circle.\\n\\n![grid line](/img/radar_svg_boundingbox_final.png)\\n\\n```javascript\\n// bounding box\\n<g\\n  transform={`translate(${margin.left + boundedDimensions.radius} ,${\\n    margin.top + boundedDimensions.radius\\n  } )`}\\n></g>\\n```\\n\\n## Define the scales\\n\\nAs our data shows, we have six skills (variables) that need to displayed on the radar chart. So, we need a _continuous_ scale with a `domain` of `[0,5]`.\\nRadar plot is _circular_, therefore, our scale\'s `range` must be `[0, 2 * Math.PI]`.\\n\\n```javascript\\n// This creates an array of [0, 1, 2, 3, 4, 5]\\nconst angleScaleDomain = d3.range(data[0].length + 1);\\n\\n// Accessor method to access `key` names from data\\nconst angleScaleDomainLabels = data[0].map((d) => d.key);\\n\\nconst angleScale = d3\\n  .scaleLinear()\\n  .domain(d3.extent(angleScaleDomain))\\n  .range([0, 2 * Math.PI]);\\n```\\n\\n:::info\\n\\nPlease note that we are using **radians** as javascript Math library has functions like `math.sin()` and `Math.cos()` that work with radians.\\n\\n:::\\n\\nWe can use our scale to find where to put six skills\' labels (`[\'resilience\', \'strength\', \'adaptability\', \'creativity\', \'openness\', \'confidence\']`) on the radar plot around the circle. Given our `angleScale`, we pass a number between 0 and 5 and it gives us the angle to place our label. Nevertheless, we need one more thing. We should be able to find a `[x, y]` position on the plot by giving an `angle`. How to do that? Answer is simple, we make use of our trigonometry knowledge.\\n\\nGiven an angle $\\\\theta$, we can calculate the `[x, y]` using the following formulas:\\n\\n![grid line](/img/radar_math_sin_cos.png)\\n\\nTherefore we have:\\n\\n$x= radius \\\\times \\\\cos(\\\\theta)$, and $y=radius \\\\times \\\\sin(\\\\theta)$\\n\\nIn order to draw elements at arbitrary _radii_ (e.g. tick values or skill labels), we add another variable `offset` to our function. Additionally, we rotate angles by -90 degrees or `-Math.PI/2` so the angle 0 begins at 12 O\'clock.\\n\\n```javascript\\nconst getCoordinatesForAngle = (angle, offset = 1) => {\\n  return [\\n    boundedDimensions.radius * Math.cos(angle - Math.PI / 2) * offset,\\n    boundedDimensions.radius * Math.sin(angle - Math.PI / 2) * offset,\\n  ];\\n};\\n```\\n\\nWe need another scale that I call it `radiusScale`, for our `value` field in our dataset, as each record in our dataset has `skill` and `value` attributes. Domain of `radiusScale` has to be `[min, max]` of `value` feature, and the range is the range will be `[0, radius]`.\\n\\n```javascript\\nlet allVals = [];\\ndata.map((array) => array.map((d) => allVals.push(d.value)));\\n\\nconst radiusScale = d3\\n  .scaleLinear()\\n  .domain([0, d3.max(allVals)])\\n  .range([0, boundedDimensions.radius])\\n  .nice();\\n```\\n\\nWe can use `radiusScale` to get ticks for our radar plot.\\n\\n```javascript\\nconst valueTicks = radiusScale.ticks(4);\\n```\\n\\n## Draw the radar plot\\n\\nNow that we have defined our scales, we only need to create a line generator to draw lines on the radar chart. We utilize `d3.lineRadial()` function, please see documentation [here](https://github.com/d3/d3-shape#lines). It\'s very similar to `d3.line()` except it accepts `angle()` and `radius()` methods.\\n\\n```javascript\\nconst radarLineGenerator = d3\\n  .lineRadial()\\n  .angle((d, i) => angleScale(i))\\n  .radius((d) => radiusScale(d.value))\\n  .curve(d3.curveCardinalClosed);\\n```\\n\\nWe are ready to create our radar plot. We start by drawing `grid lines` for our skills as well as skills\' labels. We have our labels, therefore, we simply iterate over each one and get its angle, then find `[x, y]` using our `getCoordinatesForAngle()` and draw `<line>` from the center of the circle. For drawing the labels, we would like them to be a little bit outside of the radar plot circle, therefore, we set our `offset` to be slightly bigger than 1. Here\'s the code:\\n\\n```javascript\\n{\\n  angleScaleDomainLabels.map((label, i) => {\\n    const angle = angleScale(i);\\n    const [x, y] = getCoordinatesForAngle(angle);\\n    const [labelX, labelY] = getCoordinatesForAngle(angle, 1.1);\\n    return (\\n      <g key={i} className=\\"grid\\">\\n        <line x2={x} y2={y} stroke=\\"#E5E2E0\\" className=\\"grid-line\\" />\\n        <text\\n          x={labelX}\\n          y={labelY}\\n          textAnchor={labelX < 0 ? \'end\' : labelX < 3 ? \'middle\' : \'start\'}\\n        >\\n          {label}\\n        </text>\\n      </g>\\n    );\\n  });\\n}\\n```\\n\\nThe figure below shows the output:\\n\\n![grid line](/img/radar_gridline.png)\\n\\nWe need to draw the ticks. For each tick value, we draw a `<circle>` with `r=radiusScale(tick)` and for tick label we create a `<text>` element and set `x` and `y` positions. I set the `x` value to be slightly to the right and `y` values be vertically drawn.\\n\\n```javascript\\n{\\n  valueTicks.reverse().map((tick, i) => (\\n    <g key={i} className=\\"grid\\">\\n      <circle\\n        // style={{ filter: \'url(#dropshadow)\' }}\\n        r={radiusScale(tick)}\\n        fill=\\"#fff\\"\\n        // fill=\\"#E5E2E0\\"\\n        stroke=\\"#E5E2E0\\"\\n        fillOpacity={0.9}\\n      />\\n      <text x={5} y={-radiusScale(tick)} dy=\\".3em\\">\\n        {tick}\\n      </text>\\n    </g>\\n  ));\\n}\\n```\\n\\n![radar ticks](/img/radar_ticks.png)\\nTo finish our drawing, we need to draw the lines using our `lineGenerator`. We have two series of records for two people, so we will draw two `path` elements.\\n\\n```javascript\\n<g>\\n   <path\\n     d={radarLineGenerator(data[0])}\\n     fill=\\"#137B80\\"\\n     stroke=\\"#137B80\\"\\n     strokeWidth=\\"2.5\\"\\n     fillOpacity=\\"0.1\\"\\n   />\\n </g>\\n <g>\\n   <path\\n     d={radarLineGenerator(data[1])}\\n     fill=\\"#E6842A\\"\\n     stroke=\\"#E6842A\\"\\n     strokeWidth=\\"2.5\\"\\n     fillOpacity=\\"0.1\\"\\n   />\\n </g>\\n```\\n\\nYou can see the radar plot in the image below.\\n\\n![grid line](/img/radar_simple.png)\\n\\nIt looks nice already! Nevertheless, Let\'s add more styling to that. I would like to add some shadow to my plot and each inner circle. To be able to do that, we cannot use CSS `box-shadow`, because it gives us a rectangular shadow, so it\'s not good for non-rectangular shapes. Instead, we will use the CSS `filter` property with `drop-shadow`. Another way is to define a SVG [filter](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter) to have lots of flexibility to control the shadow and opacity to give to `drop-shadow`. For this example, I\'ll go with the former option. I created a CSS file `styles.css` and added the following CSS rules:\\n\\n```css\\ngrid circle {\\n  filter: drop-shadow(0px 5px 100px rgba(146, 212, 238, 0.9));\\n  mix-blend-mode: multiply;\\n}\\n```\\n\\n![grid line](/img/radar_overflow.png)\\n\\nThe plot looks quite beautiful. However, you can see a rectangle around it that has clipped the shade of the blue color. It can be easily fixed by adding an `overflow: \'visible\'` property to the SVG element.\\n\\n```javascript\\n<svg\\n  width={width}\\n  height={height}\\n  style={{ backgroundColor: \'#fff\', overflow: \'visible\' }}\\n>\\n  // rest of the code\\n</svg>\\n```\\n\\n![grid line](/img/radar_pretty.png)\\n\\nBy changing the `drop-shadow` values, you\'ll get very pretty plots.\\n\\n![grid line](/img/radar_pretty_2.png)\\n\\nYou can find the code here at [Github repo](https://github.com/mallahyari/vis-react-d3)"},{"id":"add-tooltip","metadata":{"permalink":"/visualdecode/blog/add-tooltip","source":"@site/blog/2023-01-22-adding-tooltip.md","title":"How to add a tooltip to a line chart","description":"\x3c!--","date":"2023-01-22T00:00:00.000Z","formattedDate":"January 22, 2023","tags":[{"label":"tooltip","permalink":"/visualdecode/blog/tags/tooltip"},{"label":"react","permalink":"/visualdecode/blog/tags/react"},{"label":"d3","permalink":"/visualdecode/blog/tags/d-3"},{"label":"line chart","permalink":"/visualdecode/blog/tags/line-chart"}],"readingTime":6.5,"hasTruncateMarker":true,"authors":[{"name":"Mehdi Allahyari","title":"Principle Research Scientist","url":"https://github.com/mallahyari","imageURL":"https://github.com/mallahyari.png","key":"mehdi"}],"frontMatter":{"slug":"add-tooltip","title":"How to add a tooltip to a line chart","authors":["mehdi"],"tags":["tooltip","react","d3","line chart"]},"prevItem":{"title":"Designing Eye-catching Radar Plots with React and D3","permalink":"/visualdecode/blog/beautiful-radar-plot"},"nextItem":{"title":"Visualizing Data with Line Charts in React and D3","permalink":"/visualdecode/blog/linechart-visualization"}},"content":"\x3c!--\\nimport TOCInline from \'@theme/TOCInline\';\\n\\n<details>\\n<summary> Table of Contents</summary>\\n\\n<TOCInline toc={toc} />\\n</details> --\x3e\\n\\n## Introduction\\n\\nCreating a tooltip for a line chart can be a great way to add interactivity and provide additional information to your data visualization. In this blog post, I will show you how to create a tooltip for a line chart using D3 and React.\\n\\n\x3c!--truncate--\x3e\\n\\n## Step 1: Set up the line chart\\n\\nThe first step is to set up the line chart. You can use any charting library to create your line chart. You can read my post [visualizing data with line chart](./2023-01-15-linechart.md) and generate the line chart.\\n\\n## Step 2: Create the tooltip\\n\\nThe next step is to create the tooltip. We can use third party libraries such as [react-tooltip](https://github.com/ReactTooltip/react-tooltip), yet again where will be the fun of it?! All jokes aside, our goal here is to learn how to create our own custom tooltip for our visualizations. Nevertheless, in future we will use some existing libraries. You can create a new `div` element for the tooltip and give it an initial position, such as `display: \'none\'`, to hide it initially. You can then use React state to keep track of whether or not the tooltip should be displayed.\\n\\nOur tooltip needs some basic CSS properties like initial positioning, background color, etc. I create a `styles.css` file and defined the following properties:\\n\\n```css\\n#wrapper {\\n  position: relative;\\n}\\ntooltip {\\n  opacity: 1;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  padding: 0.3em 1em;\\n  background: #fff;\\n  text-align: center;\\n  border: 1px solid #ddd;\\n  z-index: 10;\\n  transition: all 0.2s ease-out;\\n  /* Prevent tooltip from receiving the mouse events we will be implementing */\\n  pointer-events: none;\\n}\\n\\n/* Adds an arrow pointing down at the hovered bar */\\n.tooltip:before {\\n  content: \'\';\\n  position: absolute;\\n  bottom: 0;\\n  left: 50%;\\n  width: 12px;\\n  height: 12px;\\n  background: white;\\n  border: 1px solid #ddd;\\n  border-top-color: transparent;\\n  border-left-color: transparent;\\n  transform: translate(-50%, 50%) rotate(45deg);\\n  transform-origin: center center;\\n  z-index: 10;\\n}\\n```\\n\\nIn order for our toolip to work properly, it must have an absolute position (`position: absolute`) and its parent container (`div` with id of `wrapper`) needs to have a relative position (`position: relative`). `.tooltip:before` pseudo-selector will add an arrow pointing down at the hovered point. Also `pointer-events: none` prevents the tootip from stealing to mouse events as we\'ll add the events to our line and not the tooltip. The snippet below partially shows the `linechart.js` along with our tooltip component:\\n\\n```javascript\\n<div id=\\"wrapper\\">\\n  <svg width={width} height={height} style={{ backgroundColor: \'#F5F3F2\' }}>\\n    // line chart code\\n  </svg>\\n  <div className=\\"tooltip\\">\\n    <div>Date:</div>\\n    <div>Price:</div>\\n  </div>\\n</div>\\n```\\n\\nToolitp is positioned in the top left of our `wrapper` div.\\n![tooltip-initial](/img/tooltip-initial.png)\\n\\n## Step 3: Add event listeners\\n\\nTo make the tooltip interactive, you need to add event listeners to the line chart. You can use the `onMouseMove` and `onMouseLeave` events to detect when the user hovers over the line chart. However, instead of catching hover events for individual points of the line chart, we want to show a tooltip whenever a user is hovering anywhere on the chart. Therefore, we need to cover the entire bounding box of the line chart. To make that happen, we have to create a `<rect>` that spans our bounding box and add mouse event listeners to it.\\n\\n```javascript\\n<rect\\n  width={boundedDimensions.width}\\n  height={boundedDimensions.height}\\n  fill=\\"transparent\\"\\n  onMouseMove={(e) => handleMouseMove(e)}\\n  onMouseLeave={handleMouseLeave}\\n/>\\n```\\n\\nPlease note that we don\'t need to specify the `x` and `y` attributes since they both default to 0. Also we have to set `<rect>`\'s `fill` property to `transparent`, otherwise we will see a black rectangle covering the whole chart.\\n\\n## Step 4: Show the tooltip\\n\\nWhen the user hovers anywhere over the line chart, we can use React state to update the position and visibility of the tooltip.\\n\\n```javascript\\n// Tooltip data\\nconst [tooltipData, setTooltipData] = useState({});\\n\\n// Flag to control whether to show or hide tooltip\\nconst [showTooltip, setShowTooltip] = useState(false);\\n\\n// x, y postion of closest point for drawing a circle\\n// around the point on the chart\\nconst [xPos, setXPos] = useState(0);\\nconst [yPos, setYPos] = useState(0);\\n```\\n\\nAlthough we can use the `event.clientX` and `event.clientY` properties to get the current mouse position directly, we\'d rather use [d3.pointer()](https://github.com/d3/d3-selection/blob/main/README.md#pointer) to transform the event position to the local coordinate system of the element that received the event. And use that position to set the tooltip\'s position.\\n\\n```javascript\\nconst handleMouseMove = (e) => {\\n  const mouseXYPos = d3.pointer(e);\\n  console.log(mouseXYPos);\\n};\\n\\n// Example of mouse position as an [x, y] array in\\n// the console output while moving the mouse\\n[689, 284];\\n```\\n\\n## Step 5: Add the data to the tooltip\\n\\nWhen the user hovers over the line chart, we can use the data associated with that point to update the tooltip. We can use the `d3.bisector()` function to find the closest point on the line chart to the current mouse position and then use the data associated with that point to update the tooltip. To find the closes point, we can use the x position of the `mouseXYPos` point. Then using our `xScale.invert()` function, we convert from `range` (i.e. pixels) to the `domain` (i.e. dates in our dataset).\\n\\n```javascript\\nconst xPos = mouseXYPos[0];\\nconst hoveredDate = xScale.invert(xPos);\\n```\\n\\nNext, we have to find the closest data point, i.e. the data point with the _closest date_, in our dataset that this `hoveredDate`. We can define a function that computes the distance via some _comparator_ between two adjacent items. We run that for all the items in the dataset, and find the index of the item with least distance. However, d3 comes to save us by providing these many utility functions including one for this purpose. [d3.bisector(accessor/comparator)](https://github.com/d3/d3-array) returns a new bisector using the specified _accessor_ or _comparator_ function. In other words, it returns the insertion point for x in _array_ to maintain sorted order. If x is already present in array, the insertion point will be before (to the left of) or after (to the right) any existing entries depending on if we choose `bisectLeft` or `bisectRight`.\\n\\n```javascript\\nconst bisectDate = d3.bisector((d) => xAccessor(d)).right;\\nconst closestIndex = bisectDate(data, hoveredDate);\\n```\\n\\nWe have the index of the closest point, so we can easily\\n\\n- retrieve the corresponding data item\\n- calculate the position of the tooltip to be displayed\\n- update the tooltip data and React state\\n\\n```javascript\\nconst closestDataPoint = data[closestIndex];\\nconst closestXValue = xAccessor(closestDataPoint);\\nconst closestYValue = yAccessor(closestDataPoint);\\nconst newTooltipData = {\\n  data: closestDataPoint,\\n  x: xScale(closestXValue) + dimensions.margin.left,\\n  y: yScale(closestYValue),\\n};\\nsetTooltipData(newTooltipData);\\nsetShowTooltip(true);\\nsetXPos(() => xScale(closestXValue));\\nsetYPos(() => yScale(closestYValue));\\n```\\n\\nIn addition to the tooltip, I added a vertical line `<line>`, and a `<circle>` to make the toolip more readable.\\n\\n```javascript\\n  <circle\\n    cx={xPos}\\n    cy={yPos}\\n    r=\\"3\\"\\n    fill=\\"white\\"\\n    stroke=\\"#BD2D28\\"\\n    strokeWidth=\\"2\\"\\n    pointerEvents=\\"none\\"\\n  />\\n  <line\\n    x1={xPos}\\n    y1={0}\\n    x2={xPos}\\n    y2={boundedDimensions.height}\\n    stroke=\\"#0F8C79\\"\\n    strokeWidth=\\"2\\"\\n    strokeDasharray=\\"5,4\\"\\n    pointerEvents=\\"none\\"\\n  />\\n```\\n\\n![tooltip](/img/tooltip-final.png)\\n\\n## Step 6: Add styling\\n\\nWe can use CSS to style the tooltip and make it look more attractive. I simply added a few CSS properties in the `styles.css` to make the tooltip slightly more appealing.\\n\\n```css\\n.tooltip-info {\\n  font-size: 12px;\\n  text-align: left;\\n}\\n.tooltip p {\\n  margin-top: 5px;\\n  margin-bottom: 5px;\\n}\\n```\\n\\nAdditionally, I refactored the code a bit and created a separate component for the tooltip.\\n\\n```javascript\\nconst Tooltip = ({ tooltipData }) => {\\n  const { data } = tooltipData;\\n  return (\\n    <div\\n      className=\\"tooltip\\"\\n      style={{\\n        transform: `translate(calc(-50% + ${tooltipData.x}px), calc(-100% + ${tooltipData.y}px))`,\\n      }}\\n    >\\n      <div className=\\"tooltip-info\\">\\n        <p>\\n          <strong>Date: </strong>\\n          {data.Date}\\n        </p>\\n        <p>\\n          <strong>Price: </strong> {Number.parseFloat(data.Close).toFixed(2)}\\n        </p>\\n      </div>\\n    </div>\\n  );\\n};\\n```\\n\\nHere\'s our final tooltip:\\n![final tooltip](/img/linechart-tooltip.gif)\\n\\nIn summary, adding a tooltip to a line chart is a great way to make your data visualization more interactive and informative. With the help of React, you can easily create a tooltip that displays additional information when a user hovers over a specific point. You can find the code in this [Github repo](https://github.com/mallahyari/vis-react-d3)."},{"id":"linechart-visualization","metadata":{"permalink":"/visualdecode/blog/linechart-visualization","source":"@site/blog/2023-01-15-linechart.md","title":"Visualizing Data with Line Charts in React and D3","description":"\x3c!--","date":"2023-01-15T00:00:00.000Z","formattedDate":"January 15, 2023","tags":[{"label":"data visualization","permalink":"/visualdecode/blog/tags/data-visualization"},{"label":"react","permalink":"/visualdecode/blog/tags/react"},{"label":"d3","permalink":"/visualdecode/blog/tags/d-3"},{"label":"line chart","permalink":"/visualdecode/blog/tags/line-chart"}],"readingTime":11.19,"hasTruncateMarker":true,"authors":[{"name":"Mehdi Allahyari","title":"Principle Research Scientist","url":"https://github.com/mallahyari","imageURL":"https://github.com/mallahyari.png","key":"mehdi"}],"frontMatter":{"slug":"linechart-visualization","title":"Visualizing Data with Line Charts in React and D3","authors":["mehdi"],"tags":["data visualization","react","d3","line chart"],"hide_table_of_contents":false,"toc_min_heading_level":2,"toc_max_heading_level":5},"prevItem":{"title":"How to add a tooltip to a line chart","permalink":"/visualdecode/blog/add-tooltip"}},"content":"\x3c!--\\nimport TOCInline from \'@theme/TOCInline\';\\n\\n<details>\\n<summary> Table of Contents</summary>\\n\\n<TOCInline toc={toc} />\\n</details> --\x3e\\n\\n## Introduction\\n\\nData visualization is an important aspect of making sense of large amounts of data. It allows us to quickly identify patterns and trends, and make informed decisions based on that information. React and D3.js are two powerful tools that can be used together to create powerful and interactive data visualizations. \x3c!--truncate--\x3e\\n\\nIn this blog post, we\'ll explore how to use React and D3.js to create data visualizations, and how they can be used together to create dynamic and interactive visualizations.\\n\\nFirst, let\'s take a look at D3.js. [D3.js](https://d3js.org/), which stands for Data-Driven Documents, is a JavaScript library that allows you to create data-driven documents, such as charts and graphs, using HTML, CSS, and SVG. It has a wide range of built-in functions and tools that can be used to create a wide range of different types of visualizations.\\n\\n[React](https://reactjs.org/), on the other hand, is a JavaScript library for building user interfaces. It allows you to create reusable components that can be easily integrated into your application. React\'s virtual DOM (Document Object Model) makes it easy to update and render changes to the UI, which is important when working with dynamic data.\\n\\nCombining React and D3.js could be notoriously tricky, since they both want to handle the DOM. Nevertheless, if done properly, it allows us to take advantage of the strengths of both libraries. while D3.js can handle the creation and manipulation of the visualizations themselves, we\'d rather use it for data manipulation and let React handle the application\'s state, visualization, and user interactions. This separation of concerns allows for a more maintainable and scalable codebase.\\n\\n## Set up a React project\\n\\nWhen creating a data visualization with React and D3.js, the first step is to set up a React project. You can use the create-react-app command to set up a new project, and then install D3.js using npm.\\n\\n```bash\\nnpx create-react-app my-app\\n```\\n\\nThis will create a new directory called \\"my-app\\" that contains a basic React project.\\nOnce you have your React project set up, the next step is to install D3.js. You can do this by running the following command in your project directory:\\n\\n```bash\\nnpm install d3\\n```\\n\\nOnce your project is set up, you can start creating your visualization. Here are the general steps for creating a visualization using D3.js:\\n\\n1. Collect and prepare your data: Before creating the visualization, you\'ll need to have your data ready. This means cleaning, formatting, and organizing the data as needed.\\n\\n2. Set up the SVG container: D3.js uses SVG (Scalable Vector Graphics) to create visualizations. This means that you\'ll need to create an SVG element in your HTML and set its size and dimensions.\\n\\n3. Create scales: D3.js uses scales to map data values to visual elements. You\'ll need to create a scale for each dimension of your data. For example, if you\'re creating a line chart, you\'ll need to create a scale for the x-axis and a scale for the y-axis.\\n\\n4. Create the visualization: Once you have your data, container, and scales set up, you can start creating the visualization itself. This can involve creating the elements that make up the visualization (e.g. lines, bars, circles) and binding the data to those elements.\\n\\n5. Add axis, labels and legends: Adding axis, labels and legends help to understand the data better and make it clear what the visualization represents.\\n\\n6. Add interactivity: D3.js allows you to add interactivity to your visualizations, such as hover effects and animations. You can use D3\'s built-in functions and events to add interactivity to your visualization. **We, however, use React for interactions.**\\n\\n7. Test and refine: Once you have your visualization set up, you\'ll want to test it and make any necessary adjustments. This can involve adjusting the scales, tweaking the visual elements, and adding or removing interactivity as needed.\\n\\nWe leave the interactivity to a separate blog post.\\n\\n## Set up line chart with React\\n\\nIn your project directory, create a new file called `LineChart.js` and add the following code:\\n\\n```javascript\\nimport React, { useRef, useEffect } from \'react\';\\nimport * as d3 from \'d3\';\\n\\nconst dimensions = {\\n  width: 600,\\n  height: 400,\\n  margin: { top: 30, right: 30, bottom: 40, left: 50 },\\n};\\n\\nconst LineChart = ({ data }) => {\\n  const boundedDimensions = {\\n    width: dimensions.width - margin.left - margin.right,\\n    height: dimensions.height - margin.top - margin.bottom,\\n  };\\n\\n  // 1. Access the data\\n\\n  // 2. Create scales\\n\\n  // 3. Draw visualization\\n\\n  // 4. Draw axis, labels, legends, etc\\n\\n  return <svg width={dimensions.width} height={dimensions.height}></svg>;\\n};\\n```\\n\\nInside our component we need to create a **SVG** element to be able to visualize the data in the browser. Therefore, we define our SVG element and set the `width` and `height` of it.\\n\\n### Collect and prepare the data\\n\\nThe dataset that I\'ll be using contains Apple stock prices from 2013 to 2018 that I got from [Observable](https://observablehq.com/@observablehq/sample-datasets#-aapl). In order to easily work with the data, I created a [Github Gist](https://gist.github.com/mallahyari/8d4f6a43c80154bdb391edbc3f156029) and uploaded csv file. Below is a screenshot of the data columns and values.\\n\\n![Apple csv sample](/img/apple_csv.png)\\n\\nWe\'ll be using the `Date` and `Close` cloumns for our line chart. There are several ways to read and load the dataset. We are going to utilize `d3.csv()` built-in function. It\'s simply a convenient method on top of Fetch API. For more information please see its documentation [here](https://devdocs.io/d3~7/).\\n\\n```javascript\\nd3.csv(url[([, accessor], callback)]);\\n```\\n\\nTo make the code more modularized, I have defined a custom hook that loads the dataset in the `App.js` file and passes it to `LineChart` component.\\n\\n```javascript\\nimport React, { useEffect, useState } from \'react\';\\nimport { csv } from \'d3\';\\nconst useData = () => {\\n  const [data, setData] = useState();\\n  useEffect(() => {\\n    csv(\\n      \'https://gist.githubusercontent.com/mallahyari/8d4f6a43c80154bdb391edbc3f156029/raw/26792b80dbabdd6371bc9ff10c17f9a090495649/apple_stock_price.csv\'\\n    ).then((dataset) => setData(dataset));\\n  }, []);\\n\\n  return data;\\n};\\n\\nexport default useData;\\n```\\n\\n### Set up SVG container\\n\\nWhen drawing a chart, we need two containers. First one is the main SVG that holds the entire chart, axes, data elements, labels, etc. We call this container, the `wrapper`. The second one (inner container) that contains our data elements and we call it `bounding box`. We, then, need to define dimensions for both containers.\\nImage below illustrates the wrapper SVG and bounding box containers.\\n\\nimport Figure from \'@site/src/components/Figure\'\\n\\n<Figure imageSrc=\'svg_wrapper.png\' caption=\'Chart dimensions\' />\\n\\n\x3c!-- <Figure imageSrc=\'img/svg_wrapper.png\' caption=\'Chart dimensions\' /> --\x3e\\n\\nWe define a dimension object that contains the size of the wrapper and all the margins. The margins give room for axes, ticks, labels, annotation, etc.\\n\\n```javascript\\n<svg width={width} height={height} style={{ border: \'1px solid black\' }}>\\n  <g transform={`translate(${margin.left},${margin.top})`}></g>\\n</svg>\\n```\\n\\nThe `<g>` element is our bounding box that contains and _groups_ data elements visualizations. We need to **shift** bounding box to respect our top and left margins, to make sure that our chart is inside our SVG element. The CSS `transform` property allows the `<g>` element to shift its content all at once.\\n\\n```javascript\\nconst dimensions = {\\n  width: 800,\\n  height: 400,\\n  margin: { top: 30, right: 30, bottom: 40, left: 60 },\\n};\\n```\\n\\n### Define data accessors\\n\\nWhen the data is available in our `LineChart` component, we need to access the metrics (i.e. columns) that we want to visualize.\\n\\n```javascript\\n// Define accessors\\nconst dateParser = d3.timeParse(\'%Y-%m-%d\');\\nconst xAccessor = (d) => dateParser(d.Date);\\nconst yAccessor = (d) => +d.Close;\\n```\\n\\nBoth the `Date` and `Close` columns are `string`, and also, I used `d3.timeParse` to parse the string and convert it to Javascript `date` object. You can check the documentation [here](https://github.com/d3/d3-time-format).\\n\\n### Create the scales\\n\\nIn D3.js, a scale is a function that maps data values to visual elements, such as pixels on a screen. Scales are used to translate the data into the coordinate system that is used by the SVG elements that make up the visualization.\\nD3.js provides several types of [scales](https://github.com/d3/d3-scale), including linear scales, time scales, and ordinal scales, and a few more. Each type of scale is designed to work with a specific type of data. For example, a linear scale can be used to map numerical data to a continuous range of values, such as pixels on a screen, while an ordinal scale can be used to map categorical data to a discrete range of values, such as colors. You can check this [link](https://observablehq.com/@observablehq/plot-cheatsheets-scales?collection=@observablehq/plot-cheatsheets) out to play with different scales in d3.\\n\\nLinear scale is one of the most common scales used in D3.js, it allows to map a continuous domain of data [min, max] to a continuous range of pixels [0, width]. For example, in a line chart, a linear scale can be used to map the x-axis data to the horizontal position of the line on the SVG, and the y-axis data to the vertical position of the line.\\n\\n<Figure imageSrc=\\"d3_scale.png\\" caption=\\"How scales map values\\" imageCredit=\\"https://observablehq.com/@observablehq/plot-cheatsheets-scales?collection=@observablehq/plot-cheatsheets\\" />\\n\\nWe need to create two scales: (i) a scale for x-axis to map date values of our dataset into the range of `[0, width]` of our bounding box; (ii) a scale that converts stock closing price into the range of `[0, height]`.\\n\\n```javascript\\n// Define Scales\\nconst xScale = d3\\n  .scaleTime()\\n  .domain(d3.extent(data, xAccessor))\\n  .range([0, boundedDimensions.width])\\n  .nice();\\n\\nconst yScale = d3\\n  .scaleLinear()\\n  .domain(d3.extent(data, yAccessor))\\n  .range([boundedDimensions.height, 0])\\n  .nice();\\n```\\n\\nThe reason that `yScale`\'s range is `[height, 0]` is that SVG y-values start from top to bottom so we want our range to begin at the top. Additionally, we used `d3.extent()` function from [d3-array](https://github.com/d3/d3-array) to find the minimum and maximum values for `date` and `close` columns.\\n\\n### Draw the line\\n\\nNow that we have defined our scales, we can draw the line and see the result. Thankfully, d3 save us again by providing us the tools and functions to create the line. We rely on [d3-shape](https://github.com/d3/d3-shape) to map our data to a line.\\n\\n```javascript\\n// Define line generator\\nconst lineGenerator = d3\\n  .line()\\n  .x((d) => xScale(xAccessor(d)))\\n  .y((d) => yScale(yAccessor(d)));\\n```\\n\\nThe line visualization is essentially a SVG `path` element that takes a `d` attribute to create a shape. Using `d3.line()` function generates the `d` string for us, which we can use in our `path` element.\\n\\n```javascript\\n<path\\n  d={lineGenerator(data)}\\n  className=\\"line-chart\\"\\n  fill=\\"none\\"\\n  stroke=\\"#E3BA22\\"\\n  strokeWidth=\\"2\\"\\n/>\\n```\\n\\nHere\'s our line chart:\\n![linechart](/img/linechart_01.png)\\n\\nCool! the line\'s drawn properly, however, there is no axis to help us understand the chart. Let\'s create axes for our line.\\n\\n### Draw the axes\\n\\nWe can use `d3.axisBottom()` and `d3.axisLeft()` functions from d3 API to create x and y axis respectively. Nevertheless, our goal is to create axes in React. So we have to write custom code to create the axis, ticks, and their format.\\n\\nOur axis needs:\\n\\n- A line that starts from 0 to width (for x axis) or height (y axis) of our chart.\\n- All the ticks with the labels\\n\\nOur scale\'s `tick([count])` method returns approximately count representative values from the scale\u2019s domain. If count is not specified, it defaults to 10. The specified _count_ is only a hint; the scale may return more or fewer values depending on the domain. Our `xScale.ticks()` method return 7 ticks:\\n\\n![xaxis](/img/xaxis_ticks.png#center)\\n\\nSince our tick values are dates, we can use `d3.timeFormat()` with a proper format to display the ticks on the axis. I used `d3.timeFormat(%b %Y)` to show only the month and year for ticks. You can see [d3-time-format](https://github.com/d3/d3-time-format) for complete formats information. Let\'s put together everything and create the React component for x axis:\\n\\n```javascript\\nconst AxisBottom = ({ width, height, xScale }) => {\\n  return (\\n    <g className=\\"axis xaxis\\" transform={`translate(0, ${height})`}>\\n      <line x1={0} x2={width} stroke=\\"currentColor\\" />\\n\\n      {xScale.ticks().map((tickvalue, i) => (\\n        <g key={i} transform={`translate(${xScale(tickvalue)},0)`}>\\n          <line y2={6} stroke=\\"currentColor\\" />\\n          <text\\n            // y=\\"15\\"\\n            dy=\\".71em\\"\\n            fill=\\"currentColor\\"\\n            style={{\\n              fontSize: \'10px\',\\n              textAnchor: \'middle\',\\n              transform: \'translateY(15px)\',\\n            }}\\n          >\\n            {timeFormat(\'%b %Y\')(tickvalue)}\\n          </text>\\n        </g>\\n      ))}\\n    </g>\\n  );\\n};\\n```\\n\\nSeveral points worth mentioning here. We grouped the entire axis into a `<g>` element so we can easily shift it because our `(0,0)` point is at top left. So we must move the x axis to the bottom. Then, we iterate on each tick value and create a tick line and a text label for it. To better organize ticks we put each tick into a separate `<g>` element too. And lastly, we can use `y` value or CSS `transform` to shift the text labels below the ticks for better readability.\\n\\nSimilarly, for y axis we\'ll have:\\n\\n```javascript\\nconst AxisLeft = ({ height, yScale }) => {\\n  return (\\n    <g className=\\"axis yaxis\\">\\n      <line x1={0} y2={height} stroke=\\"currentColor\\" />\\n\\n      {yScale.ticks().map((tickvalue, i) => (\\n        <g key={i} transform={`translate(0,${yScale(tickvalue)})`}>\\n          <line x2={-6} stroke=\\"currentColor\\" />\\n          <text\\n            // x={-15}\\n            dy={\'.32em\'}\\n            fill=\\"currentColor\\"\\n            style={{\\n              fontSize: \'10px\',\\n              textAnchor: \'end\',\\n              transform: \'translateX(-15px)\',\\n            }}\\n          >\\n            {tickvalue}\\n          </text>\\n        </g>\\n      ))}\\n    </g>\\n  );\\n};\\n```\\n\\nWe also define labels for our axes. The x axis label should be in the middle of the axis line (i.e. `width/2`) a bit further below tick values. Similarly, the y axis label should be in the middle (i.e. `height/2`), further to the left of the axis and needs to be rotated.\\n\\n```javascript\\n{/* X axis label */}\\n<text\\n  x={boundedDimensions.width / 2}\\n  y={35}\\n  className=\\"axis-label\\"\\n  transform={`translate(0, ${boundedDimensions.height})`}\\n  style={{\\n    fontSize: \'11px\',\\n    textAnchor: \'end\',\\n  }}\\n>\\n  {xAxisLabel}\\n\\n{/* Y axis label */}\\n<text\\n  textAnchor=\\"middle\\"\\n  className=\\"axis-label\\"\\n  transform={`translate(-35,${\\n    boundedDimensions.height / 2\\n  }) rotate(-90) `}\\n  style={{\\n    fontSize: \'11px\',\\n  }}\\n>\\n  {yAxisLabel}\\n</text>\\n```\\n\\nNot to mention that I added some CSS properties to the `line` and `text` elements to make them more apealing to the eyes.\\n\\nHere\'s the final result:\\n![line chart](/img/line_chart.png)\\n\\nYou can find the code at this [Github repo](https://github.com/mallahyari/vis-react-d3)."}]}')}}]);