"use strict";(self.webpackChunkvisdecode_site=self.webpackChunkvisdecode_site||[]).push([[7606],{8794:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"exploring-data-science-job-trends-python-react-d3","metadata":{"permalink":"/visualdecode/blog/exploring-data-science-job-trends-python-react-d3","source":"@site/blog/2023-03-11-eda-dashboard.md","title":"Exploring Data Science Job Trends in the US: A Python and React Data Analysis Journey- Part 1","description":"Exploring job trends in the data science industry can reveal insights into the skills and experience employers are seeking, and help job seekers identify promising career opportunities. In this blog post, we will take a deep dive into a dataset of data science jobs in the US, exploring trends in job titles, companies, and job announcement platforms. We will also use topic modeling to extract insights from job titles. Finally, we will build an interactive dashboard with React and D3 to visualize our findings in a way that allows users to explore and analyze the data in real-time.","date":"2023-03-11T00:00:00.000Z","formattedDate":"March 11, 2023","tags":[{"label":"topic modeling","permalink":"/visualdecode/blog/tags/topic-modeling"},{"label":"eda","permalink":"/visualdecode/blog/tags/eda"},{"label":"python","permalink":"/visualdecode/blog/tags/python"},{"label":"dashboard","permalink":"/visualdecode/blog/tags/dashboard"},{"label":"data analysis","permalink":"/visualdecode/blog/tags/data-analysis"}],"readingTime":18.09,"hasTruncateMarker":true,"authors":[{"name":"Mehdi Allahyari","title":"Principle Research Scientist","url":"https://github.com/mallahyari","imageURL":"https://github.com/mallahyari.png","key":"mehdi"}],"frontMatter":{"slug":"exploring-data-science-job-trends-python-react-d3","title":"Exploring Data Science Job Trends in the US: A Python and React Data Analysis Journey- Part 1","authors":["mehdi"],"tags":["topic modeling","eda","python","dashboard","data analysis"],"hide_table_of_contents":false,"toc_min_heading_level":2,"toc_max_heading_level":5},"nextItem":{"title":"Exploring Data Distributions with an Interactive Ridge Plot","permalink":"/visualdecode/blog/exploring-data-distributions-with-interactive-ridge-plot"}},"content":"Exploring job trends in the data science industry can reveal insights into the skills and experience employers are seeking, and help job seekers identify promising career opportunities. In this blog post, we will take a deep dive into a dataset of data science jobs in the US, exploring trends in job titles, companies, and job announcement platforms. We will also use topic modeling to extract insights from job titles. Finally, we will build an interactive dashboard with React and D3 to visualize our findings in a way that allows users to explore and analyze the data in real-time.\\n\\n\x3c!--truncate--\x3e\\n\\nimport Figure from \'@site/src/components/Figure\'\\n\\n<Figure imageSrc=\'eda-python-react-p1.png\' caption=\'Image generated by Muse text-to-image generation\' />\\n\\nNevertheless, I decided to split this tutorial into two parts: In the first part we will do all the data analysis and exploration in Python. And we will create an interactive dashboard to work with the processed data in the second part of this tutorial.\\n\\nOur goal is to provide a comprehensive guide to exploring and analyzing data science job trends, using real-world data and techniques. We chose this topic because the demand for data scientists is growing rapidly, and understanding the job market is essential for both job seekers and employers. We will begin by collecting and preparing the data, using a dataset that we feel is representative of the industry. We will then perform exploratory data analysis using Python, identifying trends in job titles, companies, and job announcement platforms. Next, we will use topic modeling to extract insights from job titles, looking for common themes and skills that are in high demand.\\n\\nFinally, we will build an interactive dashboard with React and D3 to visualize our findings in a way that allows users to explore and analyze the data in real-time. We will showcase multiple visualizations, such as bar charts, heatmaps, and word clouds, that will be linked together to provide a cohesive and intuitive experience.\\n\\nWe believe that this approach will provide readers with a comprehensive guide to exploring and analyzing data science job trends. By combining real-world data with industry-standard tools and techniques, we hope to empower readers to gain insights into the job market, identify promising career opportunities, and make data-driven decisions.\\n\\n## Collecting and Preparing the Data\\n\\nBefore we can begin our analysis, we need to collect and prepare our data. We are going to use a dataset from Kaggle, [2023 Data Scientist Job Descriptions](https://www.kaggle.com/datasets/diegosilvadefrana/2023-data-scientists-jobs-descriptions). It\'s a very recent dataset, which makes it even more interesting. We download the file and save it locally for easy access.\\n\\n```python\\n# Read and load the file\\ndf = pd.read_csv(\'ds_jobs.csv\')\\n```\\n\\nImage below shows a few rows of this dataset.\\n![dataset dataframe snippet](/img/eda-df.png)\\n\\nOnce we have our dataset, we need to clean it up to make sure it is consistent and usable. This may involve removing duplicates, correcting errors, filling in missing values, and converting data types as needed. Although, it\'s already mentioned on Kaggle that this dataset has no missing value, let\'s take a look and make sure of it.\\n\\n```python\\n# Get statistics about dataframe columns\\ndf.describe(include=\'all\')\\n```\\n\\n![df statistics](/img/eda-df-stat.png)\\n\\nAs the image shows there is no missing values in any of the columns. Depending on the type of analysis we\'re interested in, we may need to further pre-process our data like removing stop words, punctuation and special characters, lowercasing the text, etc. Next step is to define what kinds of analyses we want to do.\\n\\n## Exploratory Data Analysis (EDA)\\n\\nAs a data scientist, here are _some_ interesting analyses that can be run on this dataset:\\n\\n1. Top Companies: Analyze the dataset to find out which companies are hiring the most for data science-related jobs.\\n2. Most Popular Job Titles: Determine which job titles are most frequently advertised in the dataset.\\n3. Announcements Distribution: Explore the distribution of job postings across different job announcement platforms.\\n4. Job Descriptions Analysis: Analyze the job descriptions to identify the most common technical skills or qualifications required for data science roles.\\n5. Job Level Analysis: Categorize the job titles in the dataset by level (e.g., junior, senior, manager) and analyze the distribution of job levels.\\n6. Text Analysis: Perform text analysis on job titles and job descriptions to identify the most common words or phrases used in the data science job market.\\n7. Correlation between job title and required level of education or experience for data science positions.\\n8. Word Cloud: Generate a word cloud to visualize the most common words in the job titles.\\n9. Job Title Similarity: Use clustering algorithms to group similar job titles together and identify any patterns in the way companies name their job titles.\\n10. Topic modeling on job titles: To gain insights into the most common themes and subtopics that are present in data science job titles\\n11. Average salaries for data science positions by job title and/or company. This analysis can provide insights into the earning potential of different data science roles and can help job seekers negotiate salaries and benefits.\\n\\nWe are going to work on some of them, and the remaining ones can be a good exercise for you. \ud83d\ude42\\n\\n:::info\\n\\nFor visualizations in python I will be using [Bokeh](https://docs.bokeh.org/en/latest/).\\n\\n_\\"Bokeh is a Python library for creating interactive visualizations for modern web browsers. It helps you build beautiful graphics, ranging from simple plots to complex dashboards with streaming datasets. With Bokeh, you can create JavaScript-powered visualizations without writing any JavaScript yourself.\\"_\\n\\n:::\\n\\n**What is the distribution of hiring companies?**\\nTo answer this question, we need to have the number of job posting for each company.\\n\\nTop ten companies having the most job ads are displayed below, and surprisingly it\'s not any of the FAANG companies. _Of course it\'s because our dataset is very small._\\n\\n```python\\nUpwork                              13\\nWalmart                             12\\nDice                                10\\nBooz Allen Hamilton                 10\\nCardinal Health                      6\\nSynergisticIT                        5\\nIntermountain Healthcare             4\\nStaffigo Technical Services, LLC     4\\nStaffigo                             4\\nGuidehouse                           4\\n```\\n\\nHere\'s the code that extracts job posting for companies and creates a line chart showing the distribution of jobs over companies.\\n\\n```python\\n# Extract companies (665 companies)\\ncompanies = df[\'company\'].value_counts().rename_axis(\'company\').reset_index(name=\'counts\')\\n\\nsource = ColumnDataSource(data=companies)\\n\\n# Create line chart\\np = figure(height=350, width=600, title=f\'Distribution of hiring companies\', tools=\\"\\")\\np.line(x=\'index\', y=\'counts\', line_color=\'red\', source=source, line_width=2)\\n\\n# rotate labels by 45 degrees\\np.xaxis.major_label_orientation = 3.14/4\\nticks = [0, 20, 40, 100, 150, 200, len(companies) - 1]\\np.xaxis.ticker = ticks\\nxlabel_ticks = {}\\nfor t in ticks:\\n    xlabel_ticks[t] = companies[\'company\'][t]\\np.xaxis.major_label_overrides = xlabel_ticks\\np.xaxis.axis_label = \'Companies\'\\np.yaxis.axis_label = \'Counts\'\\np.xgrid.grid_line_color = None\\n\\nshow(p)\\n```\\n\\nBecause there are 665 companies, I only show several of them on the x-axis to prevent cluttering the plot.\\n![eda-company-distribution](/img/eda-company-plot.png)\\n\\nExcept for the first few companies, others only have posted one job according to our dataset.\\n\\nUsing almost the same code with slight change, we can see **the distribution of job postings across different job announcement platforms.**\\n\\n```python\\n# Extract job announcements\\njob_announcements = df[\'announcement\'].value_counts().rename_axis(\'announcement\').reset_index(name=\'counts\')\\n\\nsource = ColumnDataSource(data=job_announcements)\\n\\n# Create line chart\\np = figure(height=350, width=600, title=f\'Distribution of job announcement platforms\')\\np.line(x=\'index\', y=\'counts\', line_color=\'red\', source=source, line_width=2)\\n\\n# rotate labels by 45 degrees\\np.xaxis.major_label_orientation = 3.14/4\\nticks = [0, 20, 40, 100, 150, 200]\\np.xaxis.ticker = ticks\\nxlabel_ticks = {}\\nfor t in ticks:\\n    xlabel_ticks[t] = job_announcements[\'announcement\'][t]\\np.xaxis.major_label_overrides = xlabel_ticks\\np.xaxis.axis_label = \'Platforms\'\\np.yaxis.axis_label = \'Counts\'\\np.xgrid.grid_line_color = None\\n\\nshow(p)\\n```\\n\\nAs the image and top ten rows show, _LinkedIn_ is the number one platform for job posting.\\n![eda-company-distribution](/img/eda-announcement-plot.png)\\n\\n```python\\n# Top-10 platforms with the most number of job postings.\\nLinkedIn        189\\nSimplyHired      79\\nZipRecruiter     66\\nSalary.com       41\\nStartup Jobs     20\\nAdzuna           20\\nGlassdoor        20\\nGreenhouse       14\\nUpwork           13\\nBuilt In         13\\n```\\n\\n### Most common words in job titles\\n\\nTo find the most common words in job titles, we need:\\n\\n- Get the list of all job titles\\n- Clean titles\\n- Tokenize titles\\n- Remove stop words\\n- Calculate word-frequency\\n- Prepare data for visualization\\n- Draw the plot\\n\\nThe following code does all the steps, please make sure to read the comments.\\n\\n```python\\nfrom nltk.tokenize import word_tokenize\\nfrom nltk.probability import FreqDist\\nfrom nltk.corpus import stopwords\\nfrom nltk import ngrams\\nimport string\\nimport re\\n\\n\\n# Extract job titles\\njob_titles = df[\'title\'].tolist()\\n\\n# Preprocessing\\nstop_words = set(stopwords.words(\'english\'))\\ntokens = []\\nprocessed_titles = []\\nfor title in job_titles:\\n    # Convert to lowercase\\n    title = title.lower()\\n    # Remove punctuation and special characters\\n    title = re.sub(r\'[^\\\\w\\\\s]\', \'\', title)\\n    # Tokenize title\\n    title_tokens = word_tokenize(title)\\n    # Remove stop words\\n    title_tokens = [token for token in title_tokens if token not in stop_words]\\n    tokens.extend(title_tokens)\\n    processed_titles.append(title_tokens)\\n\\n\\n# Calculate word frequency\\nfdist = FreqDist(tokens)\\ntop_n = 20\\ntop_words = dict(fdist.most_common(top_n))\\n\\n# Prepare data for visualization\\ndata = {\'words\': list(top_words.keys()), \'frequency\': list(top_words.values())}\\nsource = ColumnDataSource(data=data)\\n\\n# Create bar chart\\np = figure(x_range=data[\'words\'], height=350, title=f\'Top {top_n} Most Common Words in Job Titles\', toolbar_location=None, tools=\\"\\")\\np.line(x=\'words\', y=\'frequency\', line_color=\'red\', source=source, line_width=2)\\np.xaxis.major_label_orientation = 3.14/4 # rotate labels by 45 degrees\\np.xgrid.grid_line_color = None\\n\\nshow(p)\\n\\n```\\n\\nBy changing the `top_n` variable, you can see more/less common words.\\n\\n![top-20 common words](/img/eda-top20-words.png)\\n\\n`data`, `analyst`, `scientist`, `senior` and `analytics` have the highest frequencies.\\n\\nLet\'s generate the word cloud for that:\\n\\n```python\\nfrom wordcloud import WordCloud\\n\\n# Generate word cloud\\nwordcloud = WordCloud(width=800, height=400, background_color=\'white\').generate_from_frequencies(fdist)\\n\\n# Visualize word cloud\\nplt.figure(figsize=(10, 5))\\nplt.imshow(wordcloud, interpolation=\'bilinear\')\\nplt.axis(\'off\')\\nplt.show()\\n# Save to a file\\nwordcloud.to_file(\'top20-wordcloud.png\')\\n```\\n\\n![top-20 common words word cloud](/img/top20-wordcloud.png)\\n\\n### N-gram Analysis\\n\\nWe are going to analyze n-grams (i.e. bigrams and trigrams) in job titles to identify patterns or trends in job titles.\\n\\nFirst let\'s see the distribution of titles\' lengths:\\n\\n```python\\n# Calculate length of job titles\\ndf[\'title_length\'] = df[\'title\'].apply(lambda x: len(x.split()))\\n\\n# Create a histogram of title lengths\\ntitle_lengths = df[\'title_length\'].tolist()\\nhist, edges = np.histogram(df[\'title_length\'])\\n\\n# Shift to center the tick labels\\nedges = edges - (edges[1] - edges[0]) / 2\\n\\n# Create the plot\\np = figure(title=\'Title Length Distribution\',\\n           x_axis_label=\'Number of Words in Title\',\\n           y_axis_label=\'Frequency\')\\n\\np.quad(top=hist, bottom=0, left=edges[:-1], right=edges[1:], line_color=\'white\')\\np.y_range.start = 0\\n\\n# Show the plot\\nshow(p)\\n```\\n\\n![top-20 common words word cloud](/img/eda-title-length-plot.png)\\n\\nAs the image shows, titles have a range of [2, 11] words, where most titles consist of less than 5 words. Now we\'ll calculate the bigrams and trigrams.\\n\\n```python\\n# Calculate bigrams and trigrams\\nbigrams = []\\ntrigrams = []\\nfor title in processed_titles:\\n    bigrams.extend(list(ngrams(title, 2)))\\n    trigrams.extend(list(ngrams(title, 3)))\\n\\n# Calculate frequency distribution of bigrams and trigrams\\nbigram_fdist = FreqDist(bigrams)\\ntrigram_fdist = FreqDist(trigrams)\\n\\n# Print the top 10 most common bigrams\\nprint(\'Top 10 most common bigrams:\')\\nfor bigram, frequency in bigram_fdist.most_common(10):\\n    print(bigram, frequency)\\n\\n# Print the top 10 most common trigrams\\nprint(\'\\\\nTop 10 most common trigrams:\')\\nfor trigram, frequency in trigram_fdist.most_common(10):\\n    print(trigram, frequency)\\n```\\n\\nHere\'s the output of the code:\\n\\n```python\\nTop 10 most common bigrams:\\n(\'data\', \'analyst\') 341\\n(\'data\', \'scientist\') 277\\n(\'senior\', \'data\') 108\\n(\'data\', \'science\') 43\\n(\'data\', \'analytics\') 35\\n(\'sr\', \'data\') 27\\n(\'business\', \'data\') 25\\n(\'data\', \'specialist\') 23\\n(\'lead\', \'data\') 20\\n(\'data\', \'analysis\') 16\\n\\nTop 10 most common trigrams:\\n(\'senior\', \'data\', \'scientist\') 58\\n(\'senior\', \'data\', \'analyst\') 42\\n(\'business\', \'data\', \'analyst\') 20\\n(\'sr\', \'data\', \'scientist\') 16\\n(\'sr\', \'data\', \'analyst\') 11\\n(\'staff\', \'data\', \'scientist\') 9\\n(\'lead\', \'data\', \'scientist\') 9\\n(\'lead\', \'data\', \'analyst\') 9\\n(\'entry\', \'level\', \'data\') 8\\n(\'level\', \'data\', \'analyst\') 8\\n```\\n\\nLet\'s create bar chart for them:\\n\\n<details>\\n<summary>Show code</summary>\\n\\n```python\\nfrom bokeh.palettes import Category20\\nfrom bokeh.transform import linear_cmap, factor_cmap\\nfrom bokeh.palettes import Blues\\n\\n# Extract the top 10 most common bigrams and trigrams\\ntop_bigrams = bigram_fdist.most_common(10)\\ntop_trigrams = trigram_fdist.most_common(10)\\n\\n# Create a list of the bigram and trigram labels\\nbigram_labels = [\', \'.join(bigram) for bigram, _ in top_bigrams]\\ntrigram_labels = [\', \'.join(trigram) for trigram, _ in top_trigrams]\\n\\n# Create a list of the bigram and trigram frequencies\\nbigram_frequencies = [frequency for _, frequency in top_bigrams]\\ntrigram_frequencies = [frequency for _, frequency in top_trigrams]\\n\\n# Create a ColumnDataSource for the bigrams and trigrams\\nbigram_source = ColumnDataSource(data=dict(labels=bigram_labels, frequencies=bigram_frequencies))\\ntrigram_source = ColumnDataSource(data=dict(labels=trigram_labels, frequencies=trigram_frequencies))\\n\\n# Define a color map based on the height of the bars\\n# color_mapper = linear_cmap(field_name=\'frequencies\', palette=Blues[9], low=-100, high=max(bigram_frequencies))\\ncolor_mapper = linear_cmap(field_name=\'frequencies\', palette=Blues[9], low=min(bigram_frequencies), high=max(bigram_frequencies))\\n\\n\\n# Create a figure for the bigrams\\nbigram_plot = figure(y_range=bigram_labels, height=400, width=600,\\n                     title=\'Top 10 most common bigrams in job titles\')\\nbigram_plot.hbar(y=\'labels\', right=\'frequencies\', height=0.8, source=bigram_source,\\n                 line_color=\'white\')\\nbigram_plot.x_range.start = 0\\nbigram_plot.ygrid.grid_line_color = None\\n\\n# Create a figure for the trigrams\\ntrigram_plot = figure(y_range=trigram_labels, height=400, width=600,\\n                      title=\'Top 10 most common trigrams in job titles\')\\ntrigram_plot.hbar(y=\'labels\', right=\'frequencies\', height=0.8, source=trigram_source,\\n                  line_color=\'white\')\\n\\ntrigram_plot.x_range.start = 0\\ntrigram_plot.ygrid.grid_line_color = None\\n\\n# Show the plots\\nshow(bigram_plot)\\nshow(trigram_plot)\\n```\\n\\n</details>\\n\\n![trigrams word cloud](/img/bigram-barchart.png)\\n![trigrams word cloud](/img/trigram-barchart.png)\\n\\nIt seems that demand for `data analysts` is even higher than `data scientists`. Also, `senior` level positions are pretty hot too, unlike `entry-level` ones.\\n\\nImage below is **trigrams word cloud** generated from this code:\\n\\n```python\\ntrigrams_freqs = {}\\nfor tg in trigram_fdist.items():\\n    trigrams_freqs[tg[0][0] + \' \' + tg[0][1] + \' \' + tg[0][2]] = tg[1]\\n\\nfrom wordcloud import WordCloud\\n\\n# Generate word cloud\\nwordcloud = WordCloud(width=800, height=400, background_color=\'white\').generate_from_frequencies(trigrams_freqs)\\n\\n# Visualize word cloud\\nplt.figure(figsize=(8, 5))\\nplt.imshow(wordcloud, interpolation=\'bilinear\')\\nplt.axis(\'off\')\\nplt.show()\\n```\\n\\n![trigrams word cloud](/img/trigrams-wordcloud.png)\\n\\n### Identify Seniority Level\\n\\nWe are going to analyze the job titles to identify different levels of seniority (e.g., junior, senior, manager) and see if there are any trends or patterns. Since we don\'t have a seniority level column in our dataset, we need to define some rules and keywords to identify which titles are senior level.\\n\\nAfter eyeballing the dataset, I defined these keywords: _\'senior\', \'lead\', \'principal\', \'vp\', \'director\', \'staff\', \'manager\'_. You can add more keywords to the list. Next, we check each title and if any of these keywords would be in the title, we assume that job title is a `Senior` level job, `Other` otherwise.\\n\\n```python\\n# Define a function to identify seniority level based on keywords in the job title\\ndef get_seniority_level(title):\\n    senior_keywords = [\'senior\', \'lead\', \'principal\', \'vp\', \'director\', \'staff\', \'manager\']\\n    for keyword in senior_keywords:\\n        if keyword in title.lower():\\n            return \'Senior\'\\n    return \'Other\'\\n\\n# Apply the get_seniority_level function to the job title column and create a new seniority_level column\\ndf[\'seniority_level\'] = df[\'title\'].apply(get_seniority_level)\\n\\n# Group the data by seniority level and count the number of job titles in each group\\ngrouped_df = df.groupby(\'seniority_level\')[\'title\'].count().reset_index(name=\'count\')\\n\\n# Create a Bokeh ColumnDataSource object for the bar chart\\nsource = ColumnDataSource(grouped_df)\\n\\n# Create the bar chart with Bokeh\\np = figure(x_range=grouped_df[\'seniority_level\'], height=400, width=600,\\n           title=\'Distribution of Job Titles by Seniority Level\')\\n\\np.vbar(x=\'seniority_level\', top=\'count\', width=0.9, source=source)\\np.xgrid.grid_line_color = None\\np.y_range.start = 0\\np.xaxis.axis_label = \'Seniority Level\'\\np.yaxis.axis_label = \'Number of Job Titles\'\\n\\nshow(p)\\n```\\n\\nWe can see that almost 30% of the total job titles are senior level. One interesting observation would be to compare this across multiple years and see the trend, if we had data from previous years.\\n\\n![seniority level bar chart](/img/seniority-level-plot.png)\\n\\n## Topic modeling on Job Titles\\n\\nTopic modeling is a natural language processing technique that can be used to identify topics or themes that are present in a large collection of text data. In the context of job titles, topic modeling can be used to identify the underlying topics or themes that are most common in data science job titles.\\n\\nHere are the steps to perform topic modeling on job titles:\\n\\n1. Clean and pre-process the job titles data, removing stop words, punctuation, and other non-relevant information.\\n2. Convert the preprocessed job titles data into a document-term matrix (DTM), which is a table that represents the frequency of each word in each job title.\\n3. Use a topic modeling algorithm, such as Latent Dirichlet Allocation (LDA), to identify the underlying topics or themes in the job titles data. The algorithm will identify the most common word combinations or \\"topics\\" that are present in the data.\\n4. Inspect the resulting topics to understand what they represent and give them meaningful labels. For example, a topic could be labeled \\"Machine Learning Engineer\\" if it includes words like \\"machine learning\\", \\"engineer\\", and \\"data\\".\\n5. Assign each job title to one or more topics based on the words it contains.\\n6. Analyze the distribution of topics across different job titles, companies, or other factors to identify patterns and trends in the data.\\n   By using topic modeling on job titles, you can gain insights into the most common themes and subtopics that are present in data science job titles, which can help you understand the skills and qualifications that are most in demand in the data science job market.\\n\\nThere are several libraries to do topic modeling including [Gensim](https://radimrehurek.com/gensim/index.html) and [BERTopic](https://maartengr.github.io/BERTopic/index.html#visualize-topic-similarity). For this post we are using Gensim.\\n\\nWe\'re using NLTK to clean and tokenize job titles. Then, we create a Gensim `corpus`, which is bag-of-words for titles. Then, we train an LDA model with different number of topics and choose the best one.\\n\\n```python\\nimport numpy as np\\nimport nltk\\nfrom nltk.corpus import stopwords\\nfrom nltk.stem import WordNetLemmatizer\\n\\nfrom gensim.corpora import Dictionary\\nfrom gensim.models import LdaModel\\nfrom gensim.models.coherencemodel import CoherenceModel\\n\\nnltk.download(\'stopwords\')\\nnltk.download(\'wordnet\')\\n\\nstop_words = stopwords.words(\'english\')\\nlemmatizer = WordNetLemmatizer()\\n\\ndef preprocess(text):\\n    tokens = nltk.word_tokenize(text.lower())\\n    tokens = [token for token in tokens if token not in stop_words and token.isalpha()]\\n    tokens = [lemmatizer.lemmatize(token) for token in tokens]\\n    return tokens\\n\\n# Preprocess the job titles\\ndf[\'title_tokens\'] = df[\'title\'].apply(preprocess)\\n\\n# Create a dictionary from the job titles\\ndictionary = Dictionary(df[\'title_tokens\'])\\n\\n# Create a corpus from the dictionary and job titles\\ncorpus = [dictionary.doc2bow(title_tokens) for title_tokens in df[\'title_tokens\']]\\n\\n# Train the LDA model\\ntopics_range = [3,4,5,6,10]\\nn_topics = 0\\ncohs = []\\nfor num_topics in topics_range:\\n    lda_model = LdaModel(corpus=corpus, id2word=dictionary, num_topics=num_topics, passes=10, iterations=400)\\n\\n    cm = CoherenceModel(model=lda_model, texts=df[\'title_tokens\'].values.tolist(), coherence=\'c_v\')\\n    # cm = CoherenceModel(model=lda_model, corpus=corpus, coherence=\'u_mass\')\\n\\n    coherence = cm.get_coherence()\\n    cohs.append(coherence)\\n    print(f\\"Number of topics: {num_topics}, Coherence: {coherence}\\")\\n\\n# Select the optimal number of topics\\nn_topics = topics_range[np.argmax(cohs)]\\nlda_model = LdaModel(corpus=corpus, id2word=dictionary, num_topics=n_topics, passes=10, iterations=500)\\n```\\n\\nBy Computing the topic coherence, we can find out which number of topics is optimal. The bigger the coherence, the better the model is.\\n\\n```python\\nCoherence: [0.5042733998871213, 0.4928157708829004, 0.5143670187831766, 0.5048272794509646, 0.47200016930420247]\\n```\\n\\n5 is the best number of topics in my experiment. You may get different number of topics as it may change for different iterations.\\n\\nLet\'s see the top-10 words for each topic:\\n\\n```python\\n# Print the top 10 words for each topic\\nfor topic_id, topic_words in lda_model.show_topics(num_topics=n_topics, num_words=10, formatted=False):\\n    print(f\\"Topic {topic_id}: {[word[0] for word in topic_words]}\\")\\n```\\n\\n```python\\nTopic 0: [\'data\', \'analyst\', \'remote\', \'sr\', \'clinical\', \'iii\', \'scientist\', \'lead\', \'developer\', \'hybrid\']\\nTopic 1: [\'scientist\', \'data\', \'senior\', \'analytics\', \'level\', \'staff\', \'ii\', \'entry\', \'job\', \'product\']\\nTopic 2: [\'data\', \'analyst\', \'specialist\', \'science\', \'intern\', \'associate\', \'analytics\', \'senior\', \'director\', \'hybrid\']\\nTopic 3: [\'data\', \'analyst\', \'senior\', \'analytics\', \'business\', \'manager\', \'science\', \'engineer\', \'lead\', \'health\']\\nTopic 4: [\'data\', \'analysis\', \'analyst\', \'scientist\', \'program\', \'science\', \'machine\', \'learning\', \'business\', \'lead\']\\n```\\n\\nBy looking at the top words of each topic we can manualy label the topics _subjectively_:\\n\\n- Topic 0 label: data analyst\\n- Topic 1 label: data scientist\\n- Topic 2 label: entry level data analyst and analytics\\n- Topic 3 label: data analyst and busines analytics\\n- Topic 4 label: machine learning\\n\\nWe are going to see the distribution of job titles by topics.\\n\\n```python\\n# Get the topic distribution for each job title\\ndf[\'topic_distribution\'] = df[\'title_tokens\'].apply(lambda x: lda_model[dictionary.doc2bow(x)])\\n\\n# Identify the most important topic for each job title\\ndf[\'topic\'] = df[\'topic_distribution\'].apply(lambda x: np.argmax(x,axis=0)[1])\\n\\n# Group job titles by topic and count the number of titles in each group\\ntopic_counts = df.groupby(\'topic\')[\'title\'].count()\\n\\n# Create the bar chart\\n# Create a Bokeh data source with the topic counts\\nsource = ColumnDataSource(data={\\n    \'topics\': [str(t) for t in topic_counts.index],\\n    \'counts\': topic_counts.values,\\n})\\n\\n# Define the x-axis and y-axis ranges\\nx_range = FactorRange(factors=source.data[\'topics\'])\\ny_range = (0, max(source.data[\'counts\']) * 1.1)\\n\\n# Create a figure object\\np = figure(x_range=x_range, y_range=y_range, height=400, width=800, title=\'Distribution of Job Titles by Topic\')\\n\\n# Add a vertical bar chart to the figure\\np.vbar(x=\'topics\', top=\'counts\', width=0.9, source=source, line_color=\'white\', fill_color=Spectral5[0])\\n\\n# Set visual properties for the figure\\np.xgrid.grid_line_color = None\\np.xaxis.axis_label = \'Topics\'\\np.yaxis.axis_label = \'Number of Job Titles\'\\np.yaxis.minor_tick_line_color = None\\np.yaxis.major_tick_line_color = None\\n\\n\\nshow(p)\\n```\\n\\n![job title distributions](/img/eda-topic-modeling-title-topic-dist.png)\\n\\nImage shows that topics of more than 50% of job titles either `topic 1` or `topic 3` which are `data analyst` and `data scientist` positions, respectively. Data analysts are even in higher demands according to our topics.\\nWe can use `lda_model.get_topics()`, `lda_model.get_topic_terms()`, and `lda_model.get_document_topics()` to find topic distributions at word leve, get most important topic words and distribution of topics for each title. I use one of them to create a heatmap topic-title distributions and leave the rest as an exercise.\\n\\n```python\\n# create a heatmap of the topic distributions for each job title\\nimport seaborn as sns\\nimport numpy as np\\n\\ntopic_distributions = np.zeros((len(df), n_topics))\\nfor i, doc in enumerate(corpus):\\n    for topic, prob in lda_model.get_document_topics(doc):\\n        topic_distributions[i][topic] = prob\\n\\nplt.figure(figsize=(5, 10))\\nsns.heatmap(topic_distributions, cmap=\'Blues\', cbar=True)\\nplt.xlabel(\'Topic\')\\nplt.ylabel(\'Job Title Id\')\\nplt.title(\'Topic Distributions for Job Titles\')\\nplt.show()\\n```\\n\\nThe image below shows the topic-title distributions for all the titles. The daarker the color, the higher weight that topic has for a title.\\n\\n![seniority level bar chart](/img/eda-topic-modeling-topic-title-dist.png)\\n\\nThere are several other interesting analyses that could be done. Following are just a few to name:\\n\\n- Run BERTopic and compare the results with LDA\\n- Job description analysis: Extracting salary, skills, education and \\"years of experience\\" from job description and find if there is any pattern between job titles and descriptions. For example, for extrating \\"years of experience\\", you can write a regex, however, you need to do multiple iterations to make sure you got the right data. Here\'s a good start for you:\\n\\n```python\\n# Define the regex pattern to extract years of experience from the job description\\nexp_regex = r\'(\\\\d+)\\\\+? year[s]? ?(?:of )?experience\'\\n\\n# Extract years of experience from the job description using the regex pattern\\ndf[\'years_of_experience\'] = df[\'description\'].str.extract(exp_regex)\\ndf[\'years_of_experience\'] = df[\'years_of_experience\'].fillna(0).astype(int)\\n```\\n\\nWe have done quite a bit of data analysis. Next step would be to pull some of these visualizations together and build a dashboard, so users can interact with the data. That\'s going to be next part of this tutorial.\\n\\nYou can find the Jupyter notebook code <a href=\'/notebooks/05_ds_jobs_2023.html\' target=\\"_blank\\">here</a>."},{"id":"exploring-data-distributions-with-interactive-ridge-plot","metadata":{"permalink":"/visualdecode/blog/exploring-data-distributions-with-interactive-ridge-plot","source":"@site/blog/2023-02-26-interactive-ridge-plot.md","title":"Exploring Data Distributions with an Interactive Ridge Plot","description":"--\x3e","date":"2023-02-26T00:00:00.000Z","formattedDate":"February 26, 2023","tags":[{"label":"interactive ridge plot","permalink":"/visualdecode/blog/tags/interactive-ridge-plot"},{"label":"data visualization","permalink":"/visualdecode/blog/tags/data-visualization"}],"readingTime":13.42,"hasTruncateMarker":true,"authors":[{"name":"Mehdi Allahyari","title":"Principle Research Scientist","url":"https://github.com/mallahyari","imageURL":"https://github.com/mallahyari.png","key":"mehdi"}],"frontMatter":{"slug":"exploring-data-distributions-with-interactive-ridge-plot","title":"Exploring Data Distributions with an Interactive Ridge Plot","authors":["mehdi"],"tags":["interactive ridge plot","data visualization"],"hide_table_of_contents":false,"toc_min_heading_level":2,"toc_max_heading_level":5},"prevItem":{"title":"Exploring Data Science Job Trends in the US: A Python and React Data Analysis Journey- Part 1","permalink":"/visualdecode/blog/exploring-data-science-job-trends-python-react-d3"},"nextItem":{"title":"Leveling Up Your Data Visualization Game: Animating Bar Charts with React and D3","permalink":"/visualdecode/blog/animating-bar-charts-with-react-and-d3"}},"content":"import Thumbnail from \'@site/src/components/Thumbnail\'\\n\\n\x3c!-- <Thumbnail imageSrc=\'ridge-plot-final.gif\' style={{width:\\"40%\\"}} /> --\x3e\\n\\nData visualization is a powerful tool that enables us to extract insights from large datasets, understand complex relationships between variables, and communicate results in a clear and compelling way. One particularly useful type of visualization for exploring data distributions is the ridge plot, which displays the density of data along a single axis.\\n\\n\x3c!--truncate--\x3e\\n\\nRidge plots are particularly helpful for identifying differences in distributions between multiple groups or variables. In this blog post, we\'ll explore how to create an interactive ridge plot using React and D3, two popular libraries for building web-based data visualizations. The inspiration for this work comes from an [article](https://www.ons.gov.uk/peoplepopulationandcommunity/healthandsocialcare/healthandwellbeing/articles/middleagedgenerationmostlikelytodiebysuicideanddrugpoisoning/2019-08-13) by UK Office of National Statistics. The ridge plot in that article was really captivating and interestingly, they had shared the dataset in the article. Therefore, I decided to write a blog post about ridge plots and use the same dataset. :)\\n\\nWe\'ll start with an overview of what ridge plots are and why they\'re useful, then dive into the technical details of building an interactive ridge plot using React and D3. Along the way, we\'ll discuss different use cases for interactive ridge plots and the benefits they can offer for data analysis and decision-making. By the end of this post, you\'ll have a solid understanding of how to create an interactive ridge plot and how to apply it to your own data analysis projects.\\n\\nimport Figure from \'@site/src/components/Figure\'\\n\\n<Figure imageSrc=\'ridge-plot-final.gif\' caption=\'Final interactive ridge plot\' />\\n\\n## What is a Ridge Plot?\\n\\nRidge plots are a type of data visualization that display the density of data along a single axis. They are similar to density plots, but differ in that multiple density plots are displayed in a single plot. Ridge plots are useful for displaying the distribution of data across multiple groups or variables in a compact and intuitive way.\\n\\nIn a ridge plot, the x-axis represents the variable being analyzed, while the y-axis represents the density of data at each value of the variable. The density plot for each group or variable is displayed as a ridge, with the ridges stacked on top of each other. The resulting plot looks like a mountain range, with each ridge representing a different group or variable. The width of each ridge represents the density of data at that value, with wider ridges indicating higher density.\\n\\nRidge plots offer several benefits over other types of data visualizations. For one, they are highly compact, allowing for multiple density plots to be displayed in a single plot. This can be especially useful for analyzing large datasets with multiple variables. Additionally, ridge plots are intuitive and easy to read, with the ridges providing a clear visual representation of the distribution of data across different groups or variables. Finally, ridge plots can be used to identify differences in distributions between different groups or variables, making them useful for identifying patterns and trends in data.\\n\\nOverall, ridge plots are a powerful tool for exploring data distributions, and are widely used in a variety of fields, from data science to finance to biology. In the next section, we\'ll explore how to create an interactive ridge plot using React and D3, two popular libraries for building web-based data visualizations.\\n\\n## Creating a Ridge Plot\\n\\nWe will start with a our dataset, create a SVG container, and then define and draw our ridge plot.\\n\\n### The dataset\\n\\nAs I said earlier, I downloaded the dataset from the original article\'s page and load it locally to create the plot. As you see in the snippet below, the dataset has 26 columns including `Age` and years from `1993` to `2017`. Each row represent the age and the number of people who have died each year due to drug poisoning and suicide.\\n\\n```csv\\nAge,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017\\n<10,6,4,5,4,5,6,5,4,4,2,2,1,3,3,0,5,1,5,0,3,2,2,1,1,1\\n10,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0\\n11,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0\\n\\n// remaining rows\\n```\\n\\nWhat we would like to show in the ridge plot is the _distribution or density of the number of people at different ages for each year._ In other words x-axis represents `Age`, the variable being analyzed), while the y-axis represents the density of data at each value of the variable `Age`. But we would like to stack the ridges on top of each other for each year from `1993` to `2017`. This makes it highly compact, allowing for multiple ridges to be displayed in a single plot. If I was going to show them separately, then I would have to generate 25 different plots like this:\\n\\n<Figure imageSrc=\'ridge-plot-bokeh_multiple_line_charts.png\' caption=\'Using line chart for each year increases the number of plots significantly. Additionally, it makes the comparison very difficult.\' />\\n\\nTo easily read the dataset from a URL, I\'ll be using `d3.csv()` function. I create a custom React hook to that.\\n\\n```javascript\\nexport const useData = (url) => {\\n  const [data, setData] = useState();\\n  useEffect(() => {\\n    csv(url).then((dataset) => setData(dataset));\\n  }, []);\\n\\n  return data;\\n};\\n```\\n\\n### Creating the SVG container\\n\\nThe first step in creating our ridge plot is to create an SVG container. In React, we can use the `svg` element and set its width and height attributes to create an SVG container that is the right size for our plot:\\n\\n```javascript\\nconst RidgePlot = () => {\\n  const { width, height, margin } = dimensions;\\n\\n  const boundedDimensions = {\\n    width: width - margin.left - margin.right,\\n    height: height - margin.top - margin.bottom,\\n  };\\n\\n  // Read the dataset\\n  const data = useData(datasetUrl);\\n\\n  if (!data) {\\n    return <div>Loading...</div>;\\n  }\\n\\n  return (\\n    <div>\\n      <svg className=\\"ridge-svg\\" width={width} height={height}>\\n        <g transform={`translate(${margin.left},${margin.top})`}>\\n          // ridge lines will be drawn here\\n        </g>\\n      </svg>\\n    </div>\\n  );\\n};\\n```\\n\\n### Drawing the ridge lines\\n\\nAfter we have our SVG container, we need to define our scales. However, the dataset with the current format is not very easy to work with. Thus, I transform the dataset.\\n\\n```javascript\\n// Only select year columns\\nconst years = data.columns.slice(1);\\n\\nconst transformData = () => {\\n  let newData = {};\\n  let ages = [];\\n  years.forEach((year) => {\\n    newData[year] = [];\\n  });\\n  data.forEach((item) => {\\n    years.forEach((year) => {\\n      newData[year].push({ age: item[\'Age\'], count: +item[year] });\\n    });\\n    ages.push(item[\'Age\']);\\n  });\\n  return [newData, ages];\\n};\\n```\\n\\nThe transformed dataset is as follows:\\n\\n<Figure imageSrc=\'ridge-plot-transform-data.png\' caption=\'Transformed data\' />\\n\\nwhere each object of this data has:\\n\\n<Figure imageSrc=\'ridge-plot-transform-data-object.png\' caption=\'A single item in the transformed data\' />\\n\\nNow we define our accessors and scales based on this new transformed data. Since our x-axis will be different ages and it\'s a list discrete values, we use `d3.scaleBand()`. Similarly y-axis will be a list of discrete various years, therefore, `d3.scaleBand()` would be the solution. Because we want to stack the ridge lines on top of each other, we need another scale that I call it `zScale`. This `scaleLinear()` is going to map number of suicides to the height of each ridge line.\\n\\n```javascript\\n// Define accessors\\nconst xAccessor = (d) => d.age;\\n\\n// Define Scales\\nconst xScale = d3.scaleBand().domain(ages).range([0, boundedDimensions.width]);\\n\\nconst yScale = d3\\n  .scaleBand()\\n  .domain(years)\\n  .range([0, boundedDimensions.height]);\\n\\nconst overlap = -3.5;\\n\\nconst zScale = d3\\n  .scaleLinear()\\n  .domain([0, 150])\\n  .range([0, overlap * yScale.step()]);\\n```\\n\\nTwo points:\\n\\n- `yScale` range is `[0, boundedDimensions.height]` because I would like to draw ridge lines from top of the chart to the bottom.\\n- I defined a variable `overlap` that specifies how much ridge lines overlaps each other. The bigger the number, the more overlap. The negative sign flips the ridge lines to have the mountain shape that we expect.\\n\\nWe define an `areaGenerator` using `d3.area()` to generate the `path` elements for each ridge.\\n\\n```javascript\\nconst areaGenerator = d3\\n  .area()\\n  .curve(d3.curveNatural)\\n  .x((d) => xScale(xAccessor(d)))\\n  .y0(0)\\n  .y1((d) => zScale(d.count));\\n```\\n\\nLet\'s draw the ridge lines:\\n\\n```javascript\\n<svg className=\\"ridge-svg\\" width={width} height={height}>\\n  <g transform={`translate(${margin.left},${margin.top})`}>\\n    {\\n      years.map((year, i) => (\\n        <g key={i} transform={`translate(0,${yScale(year)})`}>\\n          <path\\n            d={areaGenerator(newData[year])}\\n            fill=\\"steelblue\\"\\n            opacity=\\"1\\"\\n          />\\n        </g>\\n      ));\\n    }\\n  </g>\\n</svg>\\n```\\n\\nHere\'s the ridge plot:\\n\\n![ridge plot version 1](/img/ridge-plot-v1.png)\\n\\nAll the areas of ridge lines have the same color that makes the plot not very easily readable. To fix this issue, we can create a `<linearGradient>`. Creating a linear gradient in SVG is a simple and effective way to add color transitions to your visualizations. In SVG, you can create a linear gradient using the `<linearGradient>` element, which defines a gradient that transitions between two or more colors in a linear direction. You can find its official documentation [here](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient). The colors that the original article has used were quite pretty, and I decided to use the same colors and gradient for my plot.\\n\\n```javascript\\n<defs>\\n  <linearGradient id=\\"ridgeGradient\\" x1=\\"0%\\" y1=\\"0%\\" x2=\\"0%\\" y2=\\"110%\\">\\n    <stop offset=\\"0%\\" stopColor=\\"#dadada\\" />\\n    <stop offset=\\"0%\\" stopColor=\\"#0075A3\\" />\\n    <stop offset=\\"100%\\" stopColor=\\"#dadada\\" stopOpacity=\\"0.1\\" />\\n  </linearGradient>\\n</defs>\\n```\\n\\nNow we need to update the `fill` attribute of the `<path>` elements to use this gradient.\\n\\n```javascript\\n<path d={areaGenerator(newData[year])} fill=\\"url(#ridgeGradient)\\" opacity=\\"1\\" />\\n```\\n\\nWe will have:\\n\\n<Figure imageSrc=\'ridge-plot-v2.png\' caption=\'Ridge plot with linear gradient\' />\\n\\n### Creating the Axes\\n\\nTo create the axes, we can utilize the scales we already defined. I defined separate React component for each axis.\\n\\nWe need to move the x axis to the bottom of the chart, so we use `transform` property to conveniently shift the entire axis and its ticks to the bottom. Then by using the `map` function, we define each tick and position it accordingly. Finally, we add some styling to change the font size and aligning the text labels.\\n\\n```javascript\\nconst AxisBottom = ({ x2, xScale, transform }) => {\\n  return (\\n    <g className=\\"x-axis\\" transform={transform}>\\n      <line x2={x2} stroke=\\"#635f5d\\" />\\n      <g>\\n        <line\\n          x1={xScale(\'<10\')}\\n          x2={xScale(\'<10\')}\\n          y2={6}\\n          stroke=\\"currentColor\\"\\n        />\\n        <text x={xScale(\'<10\')} dy=\\".73\\" transform=\\"translate(0,15)\\">\\n          {\'<10\'}\\n        </text>\\n      </g>\\n      {xScale\\n        .domain()\\n        .slice(2, xScale.domain().length)\\n        .map((age, i) => {\\n          return (\\n            (i + 1) % 10 === 0 && (\\n              <g key={i}>\\n                <line\\n                  x1={xScale(age)}\\n                  x2={xScale(age)}\\n                  y2={6}\\n                  stroke=\\"currentColor\\"\\n                />\\n                <text x={xScale(age)} dy=\\".73\\" transform=\\"translate(0,15)\\">\\n                  {age}\\n                </text>\\n              </g>\\n            )\\n          );\\n        })}\\n    </g>\\n  );\\n};\\n```\\n\\nSimilarly, for y axis we have:\\n\\n```javascript\\nconst AxisRight = ({ yScale, width }) => {\\n  return (\\n    <g>\\n      {yScale.domain().map((year, i) => (\\n        <g\\n          key={i}\\n          className=\\"ridge-y-axis\\"\\n          transform={`translate(${width + 10}, 0)`}\\n        >\\n          <text y={yScale(year)} opacity=\\"1\\">\\n            {year}\\n          </text>\\n        </g>\\n      ))}\\n    </g>\\n  );\\n};\\n```\\n\\nFor x-axis label we simply need to create a `text` element and place it at the right `x` and `y` positions.\\n\\n```javascript\\n<text x={(boundedDimensions.width - margin.right) / 2} y={30}>\\n  Age\\n</text>\\n```\\n\\nThe SVG container of the `RidgePlot` component would look like this:\\n\\n```javascript\\n<g transform={`translate(0,${yScale(years[years.length - 1])})`}>\\n  <AxisBottom x2={xScale(ages[ages.length - 1])} xScale={xScale} />\\n  <text x={(boundedDimensions.width - margin.right) / 2} y={30}>\\n    Age\\n  </text>\\n</g>\\n\\n<AxisRight\\n  yScale={yScale}\\n  width={boundedDimensions.width}\\n  hoveredYear={hoveredYear}\\n/>\\n\\n{\\n  years.map((year, i) => (\\n    <g key={i} transform={`translate(0,${yScale(year)})`}>\\n      <path\\n        d={areaGenerator(newData[year])}\\n        fill=\\"url(#ridgeGradient)\\"\\n        opacity=\\"1\\"\\n      />\\n    </g>\\n  ));\\n}\\n```\\n\\nAnd our plot will look like:\\n\\n<Figure imageSrc=\'ridge-plot-v3.png\' caption=\'Ridge plot with x and y axes\' />\\n\\n## Enhancing Ridge Plot by Adding Interactivity\\n\\nNow that we\'ve covered the basics of creating a ridge plot, let\'s explore some ways we can enhance the visualization to make it more useful and engaging.\\n\\n1. One way to enhance the interactive ridge plot is to add interactivity with mouse events. For example, we can add an `onMouseEnter` event to each ridge to display a tooltip that shows the exact density value at that point. Similarly, we can add an `onMouseLeave` event to hide the tooltip when the user moves the cursor away from the ridge. These mouse events can make the interactive ridge plot more intuitive and easier to explore, by providing additional information about the data at each point.\\n\\n2. Another way to enhance the interactive ridge plot is to add transitions for smoother animation. D3 provides several transition functions that can be used to smoothly animate changes to the visualization, such as changes in the position or width of the ridges. These transitions can make the interactive ridge plot more engaging and visually appealing, by creating a sense of movement and flow.\\n\\n3. Finally, we can add axis labels and titles to the interactive ridge plot to provide additional context and clarity. Axis labels can be added to the x-axis and y-axis to indicate the variable being analyzed and the density value, respectively. Similarly, a title can be added to the top of the plot to provide a brief summary of the data being displayed. These labels and titles can make the interactive ridge plot more informative and easier to understand, by providing additional context about the data being analyzed.\\n\\nWe have already added the axes labels. We can add a title and summary of the data and plot that I\'ll skip it here as the original article already provides so much information in that regard. Therefore, we are going to add a tooltip that shows the range of the number of people who have been died when hovering over a ridge area. It also stands out the hovered ridge area and fade out other ridge areas so reader can focus on that particular ridge. Tooltip includes the x-axis and horizontal grid lines for better readability. Additionally, for smoother animation between standing out and fading out, we add a CSS `transition` property that changes the `opacity` accordingly.\\n\\nWe have to revise our code and add the event listeners. We also define a state variable to track which year ridge area is hovered.\\n\\n```javascript\\nconst [hoveredYear, setHoveredYear] = useState(-1);\\n\\n...\\n\\nconst handleMouseEnter = (year) => {\\n    setHoveredYear(year);\\n  };\\n```\\n\\nThe main changes of tge `g` element of the SVG container is highlighted below.\\n\\n```javascript\\n<g transform={`translate(${margin.left},${margin.top})`}>\\n  // highlight-start\\n  {hoveredYear === -1 && (\\n    <g transform={`translate(0,${yScale(years[years.length - 1])})`}>\\n      <AxisBottom x2={xScale(ages[ages.length - 1])} xScale={xScale} />\\n      <text x={(boundedDimensions.width - margin.right) / 2} y={30}>\\n        Age\\n      </text>\\n    </g>\\n  )}\\n  // highlight-end\\n  <AxisRight\\n    yScale={yScale}\\n    width={boundedDimensions.width}\\n    hoveredYear={hoveredYear}\\n  />\\n  {years.map((year, i) => (\\n    <g key={i} transform={`translate(0,${yScale(year)})`}>\\n      <path\\n        d={areaGenerator(newData[year])}\\n        fill=\\"url(#ridgeGradient)\\"\\n        // highlight-start\\n        opacity={hoveredYear === -1 ? 1 : hoveredYear === +year ? 1 : 0.1}\\n        onMouseEnter={() => handleMouseEnter(+year)}\\n        onMouseLeave={() => setHoveredYear(-1)}\\n        // highlight-end\\n      />\\n      // highlight-next-line\\n      {hoveredYear === +year && (\\n        <g>\\n          <AxisBottom x2={xScale(ages[ages.length - 1])} xScale={xScale} />\\n          {zScale.ticks(3).map((tick, i) => (\\n            <g key={tick}>\\n              <line\\n                x1={0}\\n                y1={zScale(tick)}\\n                x2={xScale(ages[ages.length - 1])}\\n                y2={zScale(tick)}\\n                stroke=\\"currentColor\\"\\n                strokeOpacity=\\".2\\"\\n                pointerEvents=\\"none\\"\\n              />\\n              <text y={zScale(tick) - 5} opacity=\\"0.5\\">\\n                {tick}\\n              </text>\\n            </g>\\n          ))}\\n        </g>\\n      )}\\n    </g>\\n  ))}\\n</g>\\n```\\n\\nNow we add CSS hover properties to our `styles.css` or directly inside our component, which I did the former.\\n\\n```css\\n.ridge-svg path:hover {\\n  cursor: pointer;\\n  transition: opacity 0.3s;\\n}\\n```\\n\\nHere\'s the result.\\n\\n<Figure imageSrc=\'ridge-plot-final.gif\' caption=\'Interactive ridge plot\' />\\n\\n## Use Cases for Interactive Ridge Plots\\n\\nInteractive ridge plots are a versatile data visualization tool that can be applied to a wide range of use cases in different fields. Here are some examples of how interactive ridge plots can be used to analyze and visualize different types of data:\\n\\n1. Financial Analysis: Interactive ridge plots can be used to analyze stock market data, such as the daily returns of different stocks or indices. By displaying the density of returns for each stock or index, an interactive ridge plot can help investors identify patterns and trends in the market, and make more informed investment decisions.\\n\\n2. Healthcare Analysis: Interactive ridge plots can be used to analyze patient data, such as the distribution of body mass index (BMI) scores across different demographics. By displaying the density of BMI scores for each demographic group, an interactive ridge plot can help healthcare professionals identify patterns and trends in patient health, and develop more effective treatment plans.\\n\\n3. Marketing Analysis: Interactive ridge plots can be used to analyze customer data, such as the distribution of purchase amounts for different customer segments. By displaying the density of purchase amounts for each segment, an interactive ridge plot can help marketers identify patterns and trends in customer behavior, and develop more effective marketing strategies.\\n\\n4. Climate Analysis: Interactive ridge plots can be used to analyze climate data, such as the distribution of temperature or rainfall across different regions. By displaying the density of temperature or rainfall values for each region, an interactive ridge plot can help climate scientists identify patterns and trends in climate change, and develop more accurate climate models.\\n\\nYou can find the code for this post as well as all other posts\' code at [this repo](https://github.com/mallahyari/vis-react-d3).\\n\\nThank you for reading this blog. You can follow me on [Linkedin](https://www.linkedin.com/in/mehdiallahyari/) or [Twitter](https://twitter.com/MehdiAllahyari), and please reach out if you have any comments, or interested in any custom visualization."},{"id":"animating-bar-charts-with-react-and-d3","metadata":{"permalink":"/visualdecode/blog/animating-bar-charts-with-react-and-d3","source":"@site/blog/2023-02-16-animated-barplot.md","title":"Leveling Up Your Data Visualization Game: Animating Bar Charts with React and D3","description":"Bar charts are one of the most common and versatile data visualization tools used by developers, analysts, and decision-makers across industries. They are especially useful when you want to compare and display a large amount of data quickly and clearly. By organizing data into easily distinguishable vertical bars, bar charts can convey information quickly and effectively, making them a popular choice for presenting data in reports, dashboards, and presentations.","date":"2023-02-16T00:00:00.000Z","formattedDate":"February 16, 2023","tags":[{"label":"barplot","permalink":"/visualdecode/blog/tags/barplot"},{"label":"animated","permalink":"/visualdecode/blog/tags/animated"},{"label":"data visualization","permalink":"/visualdecode/blog/tags/data-visualization"}],"readingTime":11.28,"hasTruncateMarker":true,"authors":[{"name":"Mehdi Allahyari","title":"Principle Research Scientist","url":"https://github.com/mallahyari","imageURL":"https://github.com/mallahyari.png","key":"mehdi"}],"frontMatter":{"slug":"animating-bar-charts-with-react-and-d3","title":"Leveling Up Your Data Visualization Game: Animating Bar Charts with React and D3","authors":["mehdi"],"tags":["barplot","animated","data visualization"],"hide_table_of_contents":false,"toc_min_heading_level":2,"toc_max_heading_level":5},"prevItem":{"title":"Exploring Data Distributions with an Interactive Ridge Plot","permalink":"/visualdecode/blog/exploring-data-distributions-with-interactive-ridge-plot"},"nextItem":{"title":"A Clear Picture: Visualizing Weather Types and Trends","permalink":"/visualdecode/blog/visualizing-weather-types-and-trends"}},"content":"Bar charts are one of the most common and versatile data visualization tools used by developers, analysts, and decision-makers across industries. They are especially useful when you want to compare and display a large amount of data quickly and clearly. By organizing data into easily distinguishable vertical bars, bar charts can convey information quickly and effectively, making them a popular choice for presenting data in reports, dashboards, and presentations.\\n\\n\x3c!--truncate--\x3e\\n\\nThere are many scenarios where bar charts are particularly useful. For example, they can be used to display sales data, compare different product lines, track progress towards goals, or visualize survey results. Bar charts are also an excellent tool for identifying trends and outliers, for highlighting differences between categories or groups, or even display distributions and histograms.\\n\\nimport Figure from \'@site/src/components/Figure\'\\n\\n<Figure imageSrc=\'animated-barchart.gif\' caption=\'Animated bar chart\' />\\n\\nOverall, bar charts are a highly effective way to represent numerical data in an accessible and understandable format. By animating them with React and D3, you can take your visualizations to the next level, creating interactive and engaging data displays that capture the attention of your audience and convey complex information in an intuitive and informative way.\\n\\nIn this post, I\'ll show you how to create a bar chart using React and D3, two popular frameworks for building web applications and data visualizations. We\'ll start with a basic, static bar chart that displays some sample data, and then we\'ll add some animations to make it more engaging and interactive.\\n\\n## Building a static bar chart\\n\\nBefore we dive into animating bar charts, let\'s first build a simple static bar chart to understand the basic principles of using D3 and React together. We will start with a basic dataset, create a simple SVG container, and then draw the bars for each data point. Once we have a working static bar chart, we can then move on to making it animated.\\n\\n### The dataset\\n\\nWe will start with a dataset. The dataset that I\'ll use is a [json file](https://github.com/vega/vega/blob/main/docs/data/wheat.json) having an array of records. Each record contains three properties: \\"year\\", \\"wheat\\" and \\"wages\\".\\n\\n```json\\n[\\n  { \\"year\\": \\"1565\\", \\"wheat\\": 41, \\"wages\\": 5 },\\n  { \\"year\\": \\"1570\\", \\"wheat\\": 45, \\"wages\\": 5.05 },\\n  { \\"year\\": \\"1575\\", \\"wheat\\": 42, \\"wages\\": 5.08 },\\n  { \\"year\\": \\"1580\\", \\"wheat\\": 49, \\"wages\\": 5.12 },\\n  { \\"year\\": \\"1585\\", \\"wheat\\": 41.5, \\"wages\\": 5.15 }\\n  // rest of the dataset\\n]\\n```\\n\\nWe are going to show the _distribution of wheat values time_. Each item in this dataset will represent a bar where the height of the bar will be the value of \\"wheat\\" property.\\n\\nTo easily read the dataset from a URL, I\'ll be using `d3.json()` function. I create a custom React hook to that.\\n\\n```javascript\\nconst useBarchartData = () => {\\n  const [data, setData] = useState();\\n  useEffect(() => {\\n    json(\\n      \'https://raw.githubusercontent.com/vega/vega/main/docs/data/wheat.json\'\\n    ).then((dataset) => setData(dataset));\\n  }, []);\\n\\n  return data;\\n};\\n```\\n\\n### Creating the SVG container\\n\\nThe first step in creating our bar chart is to create an SVG container. In React, we can use the `svg` element and set its width and height attributes to create an SVG container that is the right size for our chart:\\n\\n```javascript\\nconst BarChart = () => {\\n  const { width, height, margin } = dimensions;\\n  const boundedDimensions = {\\n    width: width - margin.left - margin.right,\\n    height: height - margin.top - margin.bottom,\\n  };\\n\\n  // Read the dataset\\n  const data = useBarchartData();\\n\\n  return (\\n    <div id=\\"wrapper\\">\\n      <svg width={width} height={height}>\\n        <g transform={`translate(${margin.left},${margin.top})`}>\\n          // Bars will be drawn here\\n        </g>\\n      </svg>\\n    </div>\\n  );\\n};\\n```\\n\\n### Drawing the bars\\n\\nNow that we have a container for our chart, we can start drawing the bars. We have categorical dimension for our `x` axis (i.e. list of \\"year\\" attributes), and continuous values (i.e. \\"wheat\\" values) for `y` axis. Therefore, `d3.scaleBand()` is the right choice as [band scales](https://github.com/d3/d3-scale#band-scales) are suitable for charts with _ordinal_ or _categorical_ dimensions.\\n\\n<Figure imageSrc=\'band.png\' caption=\'Band scale visual demonstration\' imageCredit=\\"https://github.com/d3/d3-scale\\" />\\n\\nwe can use the `scaleLinear` function to create a scale that maps our data \\"wheat\\" values to pixel values on the chart. We will use this scale to determine the height of each bar.\\n\\n```javascript\\n// Define accessors\\nconst xAccessor = (d) => +d.year;\\nconst yAccessor = (d) => +d.wheat;\\n\\nconst barPadding = 0.2;\\nconst xDomain = data.map((d) => xAccessor(d));\\n\\n// Define Scales\\nconst xScale = d3\\n  .scaleBand()\\n  .domain(xDomain)\\n  .range([0, boundedDimensions.width])\\n  .padding(barPadding);\\n\\nconst yScale = d3\\n  .scaleLinear()\\n  .domain(d3.extent(data, yAccessor))\\n  .range([boundedDimensions.height, 0])\\n  .nice();\\n```\\n\\nNext, we can use the `map` function to create a `rect` element for each value in our data array. We set the `x`, `y`, `width`, and `height` attributes of each rect element based on the value of the corresponding data point and the scales we created:\\n\\n```javascript\\n<svg width={width} height={height}>\\n  <g transform={`translate(${margin.left},${margin.top})`}>\\n    {data.map((d, i) => (\\n      <g key={i}>\\n        <rect\\n          x={xScale(xAccessor(d))}\\n          y={yScale(yAccessor(d))}\\n          width={xScale.bandwidth()}\\n          height={boundedDimensions.height - yScale(yAccessor(d))}\\n          fill=\\"#E6842A\\"\\n          className=\\"bar\\"\\n        />\\n      </g>\\n    ))}\\n  </g>\\n</svg>\\n```\\n\\nPlease note that for the `height` values of `rect` elements, we subtract the `yScale()` calculation from the chart `height`, because SVG coordinate `(0, 0)` starts from top left of the screen. Therefore `height - yScale(yAccessor(d))` makes the bars begin from the bottom of the SVG container rather than the top. And there you have it! We now have a basic static bar chart.\\n![bar chart without axis](/img/barchart-v1.png)\\n\\nAlthough bar chart is drawn, it\'s hard to really read it. There is no x and y axes and labels. So next step is to create axes and labels.\\n\\n### Creating the axes\\n\\nTo create the axes, we can utilize the scales we already defined. I defined separate React component for each axis.\\n\\nWe need to move the x axis to the bottom of the chart, so we use `transform` property to conveniently shift the entire axis and its ticks to the bottom. Then by using the `map` function, we define each tick and position it accordingly. Finally, we add some styling to change the font and rotate the tick labels to prevent them from overlapping.\\n\\n```javascript\\nconst BarAxisBottom = ({ width, height, xScale }) => {\\n  return (\\n    <g className=\\"axis xaxis\\" transform={`translate(0, ${height})`}>\\n      <line x1={0} x2={width} stroke=\\"currentColor\\" />\\n\\n      {xScale.domain().map((tickvalue, i) => (\\n        <g\\n          key={i}\\n          transform={`translate(${\\n            xScale(tickvalue) + xScale.bandwidth() / 2\\n          },0)`}\\n        >\\n          <line x={xScale(tickvalue)} y2={6} stroke=\\"currentColor\\" />\\n          <text\\n            dy=\\".71em\\"\\n            fill=\\"currentColor\\"\\n            style={{\\n              fontFamily: \'sans-serif\',\\n              fontSize: \'11px\',\\n              textAnchor: \'end\',\\n              dominantBaseline: \'middle\',\\n              rotate: \'-90deg\',\\n              transform: `translateX(-10px) translateY(-${\\n                xScale.bandwidth() / 2\\n              }px)`,\\n            }}\\n          >\\n            {tickvalue}\\n          </text>\\n        </g>\\n      ))}\\n    </g>\\n  );\\n};\\n```\\n\\nSimilarly, for y axis we have:\\n\\n```javascript\\nconst BarAxisLeft = ({ width, height, yScale }) => {\\n  return (\\n    <g className=\\"axis yaxis\\">\\n      <line x1={0} y2={height} stroke=\\"currentColor\\" />\\n\\n      {yScale.ticks().map((tickvalue, i) => (\\n        <g key={i} transform={`translate(0,${yScale(tickvalue)})`}>\\n          {/*  horizontal grid lines */}\\n          <line x2={width} stroke=\\"currentColor\\" strokeOpacity=\\"0.2\\" />\\n\\n          <line x2={-6} stroke=\\"currentColor\\" />\\n          <text\\n            // x={-15}\\n            dy={\'.32em\'}\\n            fill=\\"currentColor\\"\\n            style={{\\n              fontSize: \'10px\',\\n              textAnchor: \'end\',\\n              transform: \'translateX(-15px)\',\\n            }}\\n          >\\n            {tickvalue}\\n          </text>\\n        </g>\\n      ))}\\n    </g>\\n  );\\n};\\n```\\n\\nFor axes labels we simply need to create two `text` elements and place them the right `x` and `y` positions.\\n\\n```javascript\\n<text\\n  x={boundedDimensions.width / 2}\\n  y={height - margin.bottom + 20}\\n  textAnchor=\\"middle\\"\\n  fontSize=\\"12px\\"\\n>\\n  Year\\n</text>\\n<text\\n  transform={`translate(-40,${\\n    boundedDimensions.height / 2\\n  }) rotate(-90) `}\\n  style={{\\n    fontSize: \'11px\',\\n  }}\\n>\\n  Wheat\\n</text>\\n```\\n\\nOverall, the code snippet inside out `BarChart` component would look like this:\\n\\n```javascript\\n<BarAxisBottom\\n  width={boundedDimensions.width}\\n  height={boundedDimensions.height}\\n  xScale={xScale}\\n/>\\n<BarAxisLeft\\n  width={boundedDimensions.width}\\n  height={boundedDimensions.height}\\n  yScale={yScale}\\n/>\\n<text\\n  x={boundedDimensions.width / 2}\\n  y={height - margin.bottom + 20}\\n  textAnchor=\\"middle\\"\\n  fontSize=\\"12px\\"\\n>\\n  Year\\n</text>\\n<text\\n  transform={`translate(-40,${\\n    boundedDimensions.height / 2\\n  }) rotate(-90) `}\\n  style={{\\n    fontSize: \'11px\',\\n  }}\\n>\\n  Wheat\\n</text>\\n```\\n\\n<Figure imageSrc=\'barchart-v2.png\' caption=\'Bar chart with axes and labels\' />\\n\\n## Adding interactivity to the bar chart\\n\\nwe will add interactivity to our static bar chart to make it more engaging and informative. We will use the `React` library to handle the user interactions. Here are the steps we will follow:\\n\\n1. Add event listeners to our bar chart. We will use `React` to add event listeners for mouseover and mouseout events. These events will be triggered when the user hovers over or leaves a bar.\\n\\n2. Add tooltips to our bar chart. In my [How to add a tooltip to a line chart](http://localhost:3003/visualdecode/blog/add-tooltip) post, I explained how to create a custom tooltip. However, here we will use the [visx](https://airbnb.io/visx/) library to add tooltips that display information about each bar when the user hovers over it. These tooltips will provide more detailed information about the data that is being displayed.\\n\\n`visx` is a suite of several low-level standalone packages for building visual interfaces with `React`. Particularly, we will use `@visx/tooltip` package. It makes it \\"_easy to add `Tooltips` to a visualization and includes hooks, higher-order component (HOC) enhancers, and Tooltip components._\\"\\n\\nWe import the hook and `Tooltip` component from this package:\\n\\n```javascript\\nimport { useTooltip, Tooltip } from \'@visx/tooltip\';\\n```\\n\\nWe then can get values and functions we need from this hook.\\n\\n```javascript\\n\\nimport { useTooltip, Tooltip } from \'@visx/tooltip\';\\n\\n...\\nconst {\\n  showTooltip,\\n  hideTooltip,\\n  tooltipLeft,\\n  tooltipTop,\\n  tooltipOpen,\\n  tooltipData,\\n} = useTooltip();\\n```\\n\\nNow we add event listeners to our bars.\\n\\n```javascript\\n<rect\\n  x={xScale(xAccessor(d))}\\n  y={yScale(yAccessor(d))}\\n  width={xScale.bandwidth()}\\n  height={boundedDimensions.height - yScale(yAccessor(d))}\\n  fill=\\"#E6842A\\"\\n  className=\\"bar\\"\\n  // Add event listeners\\n  onMouseOver={(e) => handleMouseOver(e, d)}\\n  onMouseOut={() => hideTooltip()}\\n/>\\n```\\n\\nWe define the `handleMouseOver()` function. This function will receive the hovered bar, get its `x` and `y` values, and then updates the `tooltipTop`, `tooltipLeft` and `tooltipData` and displays the tooltip.\\n\\n```javascript\\nconst handleMouseOver = (e, d) => {\\n  const x = xScale(xAccessor(d));\\n  const y = yScale(yAccessor(d));\\n  showTooltip({\\n    tooltipLeft: x + xScale.bandwidth(),\\n    tooltipTop: y - margin.top - 50,\\n    tooltipData: d,\\n  });\\n};\\n```\\n\\nNow we need to create a `Tooltip` component after the SVG container and pass the props. We use `tooltipOpen` to only display the tooltip when a bar is hovered. Please note that the parent `div` container, which holds the SVG and `Tooltip` component must have a relative position to show the tooltip correctly on top of the hovered bar.\\n\\n```javascript\\n{\\n  tooltipOpen && (\\n    <Tooltip left={tooltipLeft} top={tooltipTop} className=\\"bar-tooltip\\">\\n      <div>\\n        <div>\\n          <p>\\n            <strong>Year: </strong>\\n            {tooltipData.year}\\n          </p>\\n          <p>\\n            <strong>Wheat: </strong>\\n            {tooltipData.wheat}\\n          </p>\\n        </div>\\n      </div>\\n    </Tooltip>\\n  );\\n}\\n```\\n\\nWe change the color of the hovered bar using CSS properties.\\n\\n```css\\n.bar:hover {\\n  fill: #684664;\\n}\\n```\\n\\nHere\'s the result.\\n\\n<Figure imageSrc=\'barchart-tooltip.png\' caption=\'Bar chart with tooltip\' />\\n\\n## Animating the bar chart with React Spring\\n\\nLet\'s explore how to make our bar chart come to life with the [React Spring](https://react-spring.dev/) animation library. React Spring is a powerful animation library for React applications that makes it easy to create complex and natural-looking animations with minimal setup. It uses the physics-based animation model to create smooth, springy, and interactive animations. They have quite a bit of examples show casing how to use the library.\\n\\nTo use React Spring, we first need to install it via npm. We can do this by running the following command in our terminal:\\n\\n```bash\\nnpm install react-spring\\n```\\n\\nOnce installed, we can import the necessary functions from React Spring into our project. The most commonly used function is `useSpring`, which returns an object with animated values that we can use to interpolate and animate our SVG elements.\\n\\nUsing `useSpring`, we can create animations that respond to user interactions, such as hovering or clicking on a bar, or that update automatically based on changes to our data. We can also control the easing and duration of the animations to create the desired effect.\\n\\nIn this section, we will add an animation to our bar chart that causes the bars to grow from the bottom to their full height when the chart is first loaded.\\nWe will use the `useSpring` function to create the animations, and we will pass the animated values to our SVG elements using the `style` attribute. By doing this, the properties of the SVG elements will be updated as the animation progresses, creating the desired effect.\\n\\nOnce we have added our animations, our static bar chart will become an engaging and interactive data visualization that is sure to capture the attention of our audience.\\n\\nThe bars are actually `rect` elements, so I will move the code that creates `rect` elements into a separate component. Therefore, we\'ll define our `AnimatedBar` as follows:\\n\\n```javascript\\nimport React from \'react\';\\nimport { useSpring, animated } from \'@react-spring/web\';\\n\\nconst AnimatedBar = ({ x, y, width, height, onMouseOver, onMouseOut }) => {\\n  const springStyle = useSpring({\\n    config: {\\n      duration: 5000,\\n    },\\n    from: {\\n      height: 0,\\n    },\\n    to: {\\n      height: height,\\n    },\\n  });\\n\\n  return (\\n    <g>\\n      <animated.rect\\n        x={x}\\n        y={y}\\n        width={width}\\n        fill=\\"#E6842A\\"\\n        className=\\"bar\\"\\n        style={{\\n          transform: springStyle.height.to(\\n            (h) => `translateY(${height - h}px)`\\n          ), // Adjust position based on height\\n          height: springStyle.height,\\n        }}\\n        onMouseOver={onMouseOver}\\n        onMouseOut={onMouseOut}\\n      />\\n    </g>\\n  );\\n};\\n```\\n\\nWe use `animated.rect` component is used to create a rectangle element that will be animated. The `style` prop is where the magic happens. The `transform` property uses the `to` method of the `springStyle.height` object to apply a CSS transform to the rectangle. The `to` method takes a function that calculates the position of the rectangle based on its current height. In this case, the function subtracts the current height from the total height of the bar, `height - h`, and uses that value to translate the rectangle vertically, `translateY(${height - h}px)`.\\n\\nAnd there you go! We have an animated bar chart.\\n\\n<Figure imageSrc=\'animated-barchart.gif\' caption=\'Animated bar chart\' />\\n\\nYou can play with different `easing` functions to change the look and feel of the animation by affecting the animation speed.\\n\\nYou can find all the code at [this repo](https://github.com/mallahyari/vis-react-d3) along with previous posts\' code.\\n\\nThank you for reading this blog. You can follow me on [Linkedin](https://www.linkedin.com/in/mehdiallahyari/) or [Twitter](https://twitter.com/MehdiAllahyari), and please reach out if you have any comments, or interested in any custom visualization."},{"id":"visualizing-weather-types-and-trends","metadata":{"permalink":"/visualdecode/blog/visualizing-weather-types-and-trends","source":"@site/blog/2023-02-03-weather-data-with-radarplot.md","title":"A Clear Picture: Visualizing Weather Types and Trends","description":"Weather has a significant impact on our daily lives, from deciding what to wear to planning outdoor activities. Understanding weather patterns and trends can be crucial in making informed decisions. In this blog post, we will explore a weather dataset and create visualizations to better understand the types of weather and their trends over time.","date":"2023-02-03T00:00:00.000Z","formattedDate":"February 3, 2023","tags":[{"label":"weather data","permalink":"/visualdecode/blog/tags/weather-data"},{"label":"data visualization","permalink":"/visualdecode/blog/tags/data-visualization"},{"label":"radar plot","permalink":"/visualdecode/blog/tags/radar-plot"}],"readingTime":11.955,"hasTruncateMarker":true,"authors":[{"name":"Mehdi Allahyari","title":"Principle Research Scientist","url":"https://github.com/mallahyari","imageURL":"https://github.com/mallahyari.png","key":"mehdi"}],"frontMatter":{"slug":"visualizing-weather-types-and-trends","title":"A Clear Picture: Visualizing Weather Types and Trends","authors":["mehdi"],"tags":["weather data","data visualization","radar plot"],"hide_table_of_contents":false,"toc_min_heading_level":2,"toc_max_heading_level":5},"prevItem":{"title":"Leveling Up Your Data Visualization Game: Animating Bar Charts with React and D3","permalink":"/visualdecode/blog/animating-bar-charts-with-react-and-d3"},"nextItem":{"title":"Designing Eye-catching Radar Plots with React and D3","permalink":"/visualdecode/blog/beautiful-radar-plot"}},"content":"Weather has a significant impact on our daily lives, from deciding what to wear to planning outdoor activities. Understanding weather patterns and trends can be crucial in making informed decisions. In this blog post, we will explore a weather dataset and create visualizations to better understand the types of weather and their trends over time.\\nThe original idea came to my mind while I was reading an article ([Practice perfect](https://www.theplot.media/p/practice)) of the [The Plot](https://www.theplot.media/) newsletter. The article was about describing whatever you\'re trying to show clearly in one sentence. The author created a visualization illustrating her fitness routine in 2022. The visualization caught my eyes instantaneously as it was quite beautiful. I got inspired by that and decided to create a similar visualization. However, I didn\'t have fitness data, therefore I chose weather data instead.\\n\\n\x3c!--truncate--\x3e\\n\\nThe dataset used in this project is part of a bigger weather dataset that I originally downloaded from [here](https://github.com/vega/vega/blob/main/docs/data/seattle-weather.csv) and contains information about the minimum and maximum temperatures, wind, and the type of weather for a specific location and time period. Using this data, we will create a radar plot that provides a clear picture of the weather patterns and trends. The radar plot is an ideal choice for this type of data as it allows us to visualize multiple variables in a single graph and compare them effectively.\\n\\nimport Figure from \'@site/src/components/Figure\'\\n\\n<Figure imageSrc=\'weather-radar-plot.png\' caption=\'Final visualization of weather dataset\' />\\n\\nWe will need to start by setting up the React project (_I will skip this part because I have already covered it in my previous posts_), importing the data, and creating the radar plot using D3, . Then, we will add additional features to the radar plot to provide more context and insights into the data. By the end of this post, you will have a better understanding of how to use React and D3 to visualize weather data and gain insights into its trends and patterns.\\n\\n## Importing the Weather Data\\n\\nWith the React project set up, you can now import the weather dataset. You can use JavaScript\'s built-in fetch API or a library like Axios to retrieve the data from a server or a local file. I created a Github Gist [here](https://gist.github.com/mallahyari/1e0a70ed89e553ecf2db7e24a9b91d65) and uploaded the file, so we can directly download and read the file in our project. We can use Fetch API or `d3.csv()` method to read the file.\\n\\n```javascript\\nimport { csv } from \'d3\';\\n\\nexport const useWeatherData = () => {\\n  const [data, setData] = useState();\\n  useEffect(() => {\\n    csv(\\n      \'https://gist.githubusercontent.com/mallahyari/1e0a70ed89e553ecf2db7e24a9b91d65/raw/02d48c2d42515dd892c41cca13c34cc1d0c09ebe/weather_fake_data.csv\'\\n    ).then((dataset) => setData(dataset));\\n  }, []);\\n\\n  return data;\\n};\\n```\\n\\n## Preparing the Data for Visualization\\n\\nAfter importing the data, you\'ll need to clean and prepare it for visualization. This may involve removing any missing values, converting data types, or aggregating the data. One of the visual data elements that I will draw is different weather types. Therefore, I needed to aggregate the data (group by) `weather` column, that you will see in the later section. You can see a snippet of the dataset including its columns:\\n\\n![weather dataset](/img/weather_dataset.png)\\n\\n## Code Explanation for Creating the Radar Plot with D3 and React\\n\\nThe first step in creating the radar plot is to set up the D3 scales and axes. The scales will be used to map the data values to the chart, and the axes will be used to define the boundaries of the chart. I defined a `WeatherPlot.js` file and added my component.\\n\\n```javascript\\n// import necessary modules\\n\\nconst dimensions = {\\n  width: 1100,\\n  height: 1100,\\n  margin: { top: 50, right: 60, bottom: 50, left: 60 },\\n};\\n\\nexport const WeatherPlot = () => {\\n  const { width, height, margin } = dimensions;\\n  const boundedDimensions = {\\n    width: dimensions.width - margin.left - margin.right,\\n    height: dimensions.height - margin.top - margin.bottom,\\n  };\\n  const boundedRadius = boundedDimensions.width / 2;\\n  const outerRadius = (boundedDimensions.width / 2) * 0.5;\\n  const innerRadius = outerRadius / 3;\\n\\n  return (\\n    <div>\\n      <svg\\n        width={width}\\n        height={height}\\n        style={{ backgroundColor: \'#000\' }}\\n      ></svg>\\n    </div>\\n  );\\n};\\n```\\n\\n### Creating the Scales\\n\\nIf you look at the data, it shows one year of data with other features. We are going to show temperatures over time, so we need two scales. One scale for _date_ and another one for _temperature_. The scale for date transforms dates into angles and other scale maps temperature numbers into distance from the center of the circle or the plot. I define my scales as follows:\\n\\n````javascript\\n// Create angle scale for mapping the dates to angles\\n  const angleScale = d3\\n    .scaleTime()\\n    .domain(d3.extent(data, dateAccessor))\\n    .range([0, 2 * Math.PI]);\\n\\n  // Create radius scale for mapping min and max temperatures to distances\\n  const radiusScale = d3\\n    .scaleLinear()\\n    .domain(\\n      d3.extent([...data.map(tempMinAccessor), ...data.map(tempMaxAccessor)])\\n    )\\n    .range([innerRadius, outerRadius])\\n    .nice();\\n    ```\\n````\\n\\nThe domain of `angleScale` is the range of `[min date, max date]` and range is the entire circle, which is `[0, 2 * Math.PI]`. For my `radiusScale`, the domain and range will be `[min temperature, max temperature]` and `[inner radius. outer radius]`, respectively.\\n\\n<Figure imageSrc=\'weather_radar_circles.png\' />\\n\\n### Creating Grid Lines and Ticks\\n\\nLet\'s create a grid line for each month and also create text labels of months. We need a function to covert angle to `[x, y]` point to be able to draw grid lines. Also, we need names of months. We can define an array with months names, however, instead of hardcoding, let\'s get them from our angle scale domain using `d3.timeMonths()` function.\\n\\n```javascript\\n// Define month names for creating text labels on the plot\\nconst months = d3.timeMonths(...angleScale.domain());\\n\\n// Define a function to convert angle into position\\nconst getCoordinatesForAngle = (angle, radius, offset = 1) => {\\n  return d3.pointRadial(angle, radius * offset);\\n};\\n```\\n\\nNow that we have what we need, let\'s draw the grid lines with labels.\\n\\n```javascript\\n{\\n  months.map((m, i) => {\\n    const angle = angleScale(m);\\n    const angleOffset = Math.PI / 12;\\n    const [x1, y1] = getCoordinatesForAngle(angle, innerRadius);\\n    const [x2, y2] = getCoordinatesForAngle(angle, outerRadius, 1.01);\\n    const [labelX, labelY] = getCoordinatesForAngle(\\n      angle + angleOffset,\\n      outerRadius,\\n      1.05\\n    );\\n    return (\\n      <g key={i}>\\n        <line\\n          x1={x1}\\n          y1={y1}\\n          x2={x2}\\n          y2={y2}\\n          strokeWidth={2}\\n          className=\\"grid-line\\"\\n        />\\n        <text x={labelX} y={labelY} textAnchor=\\"middle\\" className=\\"tick-label\\">\\n          {d3.timeFormat(\'%B\')(m)}\\n        </text>\\n      </g>\\n    );\\n  });\\n}\\n```\\n\\nHere\'s the output plot:\\n\\n![radar-gridlines](/img/weather_radar_gridlines.png)\\n\\nIt\'s pretty cool, isn\'t it? ;)\\n\\nAlthough text labels look nice, but instead of being horizontal, I would like them to rotate around the circle. Therefore, I need to use `<textPath>`, it allows us to render text along the shape of a `<path>`. Please check [this link](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/textPath) for complete description and examples.\\n\\nNevertheless, the idea is I have to create an `arc` shape path and then render my text label using that path. I need to create arc path between each two consecutive months, and then draw my text label along that path.\\n\\n<Figure imageSrc=\'weather-textpath.png\' caption=\\"Example of <textPath>\\" />\\n\\nTo be able to get month intervals, I will use [d3.utcMonth.offset(date[, step])](https://github.com/d3/d3-time/blob/main/README.md).\\n\\n```javascript\\nconst monthsTextPath = months.map((d) => [d, d3.utcMonth.offset(d, 1)]);\\n```\\n\\nLet\'s replace the months text labels generated before with these new ones.\\n\\n```javascript\\n{\\n  monthsTextPath.slice(0, 1).map(([a, b], i) => {\\n    const id = `month-path-${i}`;\\n    const angleA = angleScale(a);\\n    const angleB = angleScale(b);\\n    const movePoint = getCoordinatesForAngle(angleA, outerRadius);\\n    const arcPoint = getCoordinatesForAngle(angleB, outerRadius);\\n\\n    return (\\n      <g key={`g-${i}`}>\\n        <path\\n          key={id}\\n          id={id}\\n          d={`\\n            M${movePoint} \\n            A${outerRadius},${outerRadius} 0,0,1 ${arcPoint}`}\\n          stroke=\\"tomato\\"\\n        />\\n        <text\\n          key={`month-textPath-${i}`}\\n          textAnchor=\\"middle\\"\\n          className=\\"tick-label\\"\\n        >\\n          <textPath startOffset=\\"50%\\" href={`#${id}`}>\\n            {d3.utcFormat(\'%B\')(a)}\\n          </textPath>\\n        </text>\\n      </g>\\n    );\\n  });\\n}\\n```\\n\\nHere\'s the result:\\n\\n<Figure imageSrc=\'weather-textpath-final.png\'  />\\n\\nNext step is to create ticks for our plot, which is easily done via our `radiusScale.ticks()` function.\\n\\n```javascript\\n// Define ticks for our plot\\nconst tempTicks = radiusScale.ticks(5);\\n```\\n\\nI use the ticks to draw tick values and circles.\\n\\n```javascript\\n{\\n  tempTicks.map((t, i) => (\\n    <g key={i}>\\n      <circle r={radiusScale(t)} className=\\"grid-line\\" />\\n      <rect x={5} y={-radiusScale(t) - 10} width={30} height={20} fill=\\"#000\\" />\\n      <text x={6} y={-radiusScale(t) + 5} className=\\"tick-label-temperature\\">\\n        {`${d3.format(\'.0f\')(t)}\\\\u00b0F`}\\n      </text>\\n    </g>\\n  ));\\n}\\n```\\n\\nLet\'s see the outcome:\\n\\n![weather radar ticks](/img/weather-radar-ticks.png)\\n\\n### Drawing the Area Radial\\n\\nWe need `d3.areaRadial()` to draw the actual plot. It requires `angle()`, `innerRadius()` and `outerRadius()` to be set. By setting them and passing the dataset it generates the `<path>` for us.\\n\\n```javascript\\n// Define generators for shape of the plot\\nconst areaGenerator = d3\\n  .areaRadial()\\n  .angle((d) => angleScale(dateAccessor(d)))\\n  .innerRadius((d) => radiusScale(tempMinAccessor(d)))\\n  .outerRadius((d) => radiusScale(tempMaxAccessor(d)));\\n\\n// inside SVG tag\\n<path d={areaGenerator(data)} fill=\\"tomato\\" className=\\"area\\" />;\\n```\\n\\n![radar plot v1](/img/weather-radar-v1.png)\\n\\nWe can draw a line on the outer side or inner side of plot to make it stand out more. The code below will draw on the outer side of the plot, you can change the `lineOuterRadius()` to `lineInnerRadius()` to draw inner line, or draw both if you like. It can be easily achieved in two ways.\\n\\n```javascript\\n// Select METHOD 1 OR METHOD 2\\n// METHOD 1\\nconst lineGenerator = areaGenerator.lineOuterRadius();\\n\\n// METHOD 2\\nconst lineGenerator = d3\\n  .lineRadial()\\n  .curve(d3.curveCardinal)\\n  .angle((d) => angleScale(dateAccessor(d)))\\n  .radius((d) => radiusScale(tempMaxAccessor(d)));\\n\\n// In SVG tag\\n<path\\n  d={lineGenerator(data)}\\n  fill=\\"none\\"\\n  stroke=\\"#f8f9fa\\"\\n  className=\\"line-radial\\"\\n/>;\\n```\\n\\n<Figure imageSrc=\'weather-radar-v2.png\' caption=\\"Radar plot with outer line\\"  />\\n\\n### Changing the Color using RadialGradient\\n\\nI\'d like to change the color of the plot and use a gradient color instead to make it look even better. `<radialGradient>` is the right choice because our plot is a radial plot. You can read its [documentation](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/radialGradient) to learn more about different gradients.\\n\\nThe important attributes are `id`, `offset` and `stop-color`. We can define our `<radialGradient>` in the `<def>` tag. The `<def>` tag job is to store graphical objects that will be used later again. You can think of it as browser `localStorage`.\\n\\n```javascript\\n<defs>\\n  <radialGradient id=\\"temp-gradient\\">\\n    {d3.range(numOfStops).map((i) => (\\n      <stop\\n        key={i}\\n        offset={`${(i / (numOfStops - 1)) * 100}%`}\\n        stopColor={gradientColorScale(i / (numOfStops - 1))}\\n      />\\n    ))}\\n  </radialGradient>\\n</defs>\\n```\\n\\nTo select a gradient color, I am going to use one of d3 [color schemes](https://observablehq.com/@d3/color-schemes)\\n\\n```javascript\\n// Create gradient color for area path\\nconst gradientColorScale = d3.interpolateBrBG;\\n```\\n\\nNow I\'ll update my area path `fill` attribute to use my gradient color.\\n\\n```javascript\\n<path d={areaGenerator(data)} fill={`url(#temp-gradient)`} className=\\"area\\" />\\n```\\n\\n<Figure imageSrc=\'weather-radar-radial-gradient.png\' caption=\\"Radar plot with radial gradient\\"  />\\n\\n### Drawing Weather Types\\n\\nAwesome! We\'re done with main radar plot. However, I would like to draw weather types and the wind speed attributes into this plot as well.\\n\\nWe need to _transform_ out data, i.e. _group_ the data by various weather types. Additionally, I define `offset` values for each type, so we can draw them at different distances to prevent overlap.\\n\\n```javascript\\n// Group by the data based on `weather` types\\nconst dataGroupedByWeather = d3.group(data, (d) => d.weather);\\n\\n// Create offsets to easily draw circles with certain offset of the main radius.\\nconst weatherTypes = Array.from(dataGroupedByWeather.keys());\\nconst weatherTypeOffsets = weatherTypes.map((t, i) => ({\\n  type: t,\\n  offset: 1.18 + i * 0.1,\\n}));\\n\\nconst windOffset = 1.7;\\n```\\n\\nI also define another scale to be able to change the size of the `<circle>` elements based on the wind speed. The higher the speed, the bigger the circle. However, the _size_ of the circle and its _radius_ grow at different rates. What I mean is that if we multiply the radius of a circle by 2, its area becomes 4 times larger.\\n\\n$$area_{c_1} = \\\\pi {r_1}^2$$\\n\\n$$r_2= 2r_1 \\\\Rightarrow area_{c_2} = \\\\pi ({2r_1})^2 = 4\\\\pi {r_1}^2$$\\n\\n$$\\\\frac{area_{c_2}}{area_{c_1}} = 4$$\\n\\nSo what is the ratio or radius to the area of a circle?!\\n\\n$$r=\\\\sqrt{\\\\frac{area}{\\\\pi}} \\\\Rightarrow r \\\\propto \\\\sqrt{area}$$\\n\\nTherefore, we\'d rather use [d3.scaleSqrt()](https://github.com/d3/d3-scale#scaleSqrt) instead of a _linear_ scale.\\n\\n```javascript\\n// Create radius scale for wind numbers\\nconst windRadiusScale = d3\\n  .scaleSqrt()\\n  .domain(d3.extent(data, windAccessor))\\n  .range([2, 10]);\\n```\\n\\nI considered the range (i.e. radii of the circles) to be `[2, 10]`. I need five distinctive colors for weather types, so I used discrete colors:\\n\\n```javascript\\n// Define colors for color coding different types of weather\\nconst weatherColors = d3.schemeRdYlGn[5];\\n```\\n\\nPutting together all the pieces, we will have:\\n\\n```javascript\\n{\\n  weatherTypes.map((wt, i) =>\\n    dataGroupedByWeather.get(wt).map((d, j) => {\\n      const angle = angleScale(dateAccessor(d));\\n      const [x, y] = getCoordinatesForAngle(\\n        angle,\\n        outerRadius,\\n        weatherTypeOffsets[i].offset\\n      );\\n\\n      return (\\n        <g key={`${wt}-${i}${j}`}>\\n          <circle\\n            cx={x}\\n            cy={y}\\n            r={5}\\n            fill={weatherColors[i]}\\n            className={`${wt}-circle`}\\n          />\\n        </g>\\n      );\\n    })\\n  );\\n}\\n\\n{\\n  data.map((d, i) => {\\n    const angle = angleScale(dateAccessor(d));\\n    const [x, y] = getCoordinatesForAngle(angle, outerRadius, windOffset);\\n\\n    return (\\n      <g key={`wind-${i}`}>\\n        <circle\\n          cx={x}\\n          cy={y}\\n          r={windRadiusScale(windAccessor(d))}\\n          className={`wind-circle`}\\n        />\\n      </g>\\n    );\\n  });\\n}\\n```\\n\\nAnd our plot looks like this:\\n\\n<Figure imageSrc=\'weather-radar-v3.png\' caption=\\"Radar plot with weather types\\"  />\\n\\n### Adding Annotations to the Plot\\n\\nWe\'re almost done. The only thing left out is to annotate our plot, so if someone looks at our plot they can easily figure out all the information it\'s offering.\\nTo put it into simple words, annotation is essentially, some textual content along with some line to guide the text. Therefore, we need to draw some `<text>` and `<line>` elements.\\n\\nBecause we need several annotations, i.e. drawing several `<line>` and `<text>` elements, I defined a function to make it straightforward. This function input will be `angle`, `offset` and `text` and returns an object having `x` and `y` positions and `text` for drawing line and text.\\n\\n```javascript\\n// Define a function for creating text annotations on the plot\\nconst drawAnnotation = (angle, offset, text) => {\\n  const [x1, y1] = getCoordinatesForAngle(angle, outerRadius, offset);\\n  const [x2, y2] = getCoordinatesForAngle(angle, outerRadius, 2);\\n\\n  return { x1, x2, y1, y2, text };\\n};\\n```\\n\\nLet\'s create our annotations:\\n\\n```javascript\\n// Define annotation for various type of information\\nconst sunAnnotation = drawAnnotation(\\n  Math.PI * 0.21,\\n  weatherTypeOffsets.find((el) => el.type === \'sun\')[\'offset\'],\\n  \'Sunny days\'\\n);\\nconst rainAnnotation = drawAnnotation(\\n  Math.PI * 0.3,\\n  weatherTypeOffsets.find((el) => el.type === \'rain\')[\'offset\'],\\n  \'Rainy days\'\\n);\\nconst snowAnnotation = drawAnnotation(\\n  Math.PI * 0.05,\\n  weatherTypeOffsets.find((el) => el.type === \'snow\')[\'offset\'],\\n  \'Snowy days\'\\n);\\nconst drizzleAnnotation = drawAnnotation(\\n  Math.PI * 0.25,\\n  weatherTypeOffsets.find((el) => el.type === \'drizzle\')[\'offset\'],\\n  \'Drizzly days\'\\n);\\nconst fogAnnotation = drawAnnotation(\\n  Math.PI * 0.367,\\n  weatherTypeOffsets.find((el) => el.type === \'fog\')[\'offset\'],\\n  \'foggy days\'\\n);\\nconst windAnnotation = drawAnnotation(Math.PI * 0.15, windOffset, \'Wind\');\\n```\\n\\nI then created a React component called `Annotation`, which basically draws the line and text, given the annotation data.\\n\\n```javascript\\nconst Annotaion = ({ annotationData }) => (\\n  <g>\\n    <line\\n      x1={annotationData.x1}\\n      x2={annotationData.x2}\\n      y1={annotationData.y1}\\n      y2={annotationData.y2 + 10}\\n      className=\\"annotation-line\\"\\n    />\\n    <text\\n      x={annotationData.x2 + 5}\\n      y={annotationData.y2 + 10}\\n      className=\\"annotation-text\\"\\n    >\\n      {annotationData.text}\\n    </text>\\n  </g>\\n);\\n```\\n\\nAnd we\'re done! Here\'s the final plot:\\n\\n<Figure imageSrc=\'weather-radar-final.png\' caption=\\"Radar plot final version\\"  />\\n\\nYou can find all the code at [this repo](https://github.com/mallahyari/vis-react-d3) along with previous posts\' code.\\n\\nThank you for reading this blog. You can follow me on [Linkedin](https://www.linkedin.com/in/mehdiallahyari/) or [Twitter](https://twitter.com/MehdiAllahyari), and please reach out if you have any comments, or interested in any custom visualization."},{"id":"beautiful-radar-plot","metadata":{"permalink":"/visualdecode/blog/beautiful-radar-plot","source":"@site/blog/2023-01-26-simple-radarplot.md","title":"Designing Eye-catching Radar Plots with React and D3","description":"Radar plots, also known as spider plots or star plots, are a great way to visualize multivariate data. They are particularly useful when you want to compare multiple variables for a set of items. Here are some situations where radar plots may be useful:","date":"2023-01-26T00:00:00.000Z","formattedDate":"January 26, 2023","tags":[{"label":"data visualization","permalink":"/visualdecode/blog/tags/data-visualization"},{"label":"radar plot","permalink":"/visualdecode/blog/tags/radar-plot"},{"label":"react","permalink":"/visualdecode/blog/tags/react"},{"label":"d3","permalink":"/visualdecode/blog/tags/d-3"}],"readingTime":9,"hasTruncateMarker":true,"authors":[{"name":"Mehdi Allahyari","title":"Principle Research Scientist","url":"https://github.com/mallahyari","imageURL":"https://github.com/mallahyari.png","key":"mehdi"}],"frontMatter":{"slug":"beautiful-radar-plot","title":"Designing Eye-catching Radar Plots with React and D3","authors":["mehdi"],"tags":["data visualization","radar plot","react","d3"],"hide_table_of_contents":false,"toc_min_heading_level":2,"toc_max_heading_level":5},"prevItem":{"title":"A Clear Picture: Visualizing Weather Types and Trends","permalink":"/visualdecode/blog/visualizing-weather-types-and-trends"},"nextItem":{"title":"How to add a tooltip to a line chart","permalink":"/visualdecode/blog/add-tooltip"}},"content":"Radar plots, also known as spider plots or star plots, are a great way to visualize multivariate data. They are particularly useful when you want to compare multiple variables for a set of items. Here are some situations where radar plots may be useful:\\n\\n\x3c!--truncate--\x3e\\n\\n- _Comparing multiple variables:_ Radar plots are useful for showing how multiple variables are related to each other. They allow you to see the relative strengths and weaknesses of each variable across a set of items.\\n- _Showing relative values:_ Radar plots can be useful for showing the relative values of each variable for a set of items. This can be useful for comparing the relative strengths and weaknesses of different items.\\n\\n- _Displaying data with cyclical patterns:_ If your data has cyclical patterns, such as seasonal patterns, a radar plot can help you visualize it by plotting the variables on a circular axis.\\n\\nRadar plots tend to be among my favorite types of plots as they can convey various kinds of information simultaneously, and are also visually appealing. In this blog post, I will show you how to create a radar plot using React and D3.js. Like previous blogs, our goal is to use React for managing the DOM and utilize d3 for data manipulations.\\n\\nThere are many libraries that allow you to draw radar plots like [Plotly](https://plotly.com/python/radar-chart/), but when it comes to creating _beautiful_ plots, they are limited and don\'t have a lot of flexibility. That make sense, because their intention is more towards non-technical individuals.\\n\\nPlots do not have to be _necessarily_ visually appealing, but it is generally beneficial for them to be clear and easy to understand. A well-designed plot can help make the data more accessible and easier to interpret. This can be especially important when presenting data to non-experts or decision-makers who may not have the same level of expertise in the subject matter.\\n\\nVisual appeal can be achieved by using colors, labels, and other design elements to guide the viewer\'s eye through the data. This can help convey the main message of the plot more effectively. It is also important to choose the right type of plot for the data and the message you want to convey.\\n\\nI covered in the [visualizing line chart](./2023-01-15-linechart.md) that for creating any plot we need to follow six main steps:\\n\\n1. Prepare the data\\n2. Create the SVG element\\n3. Create the scales\\n4. Draw the (radar) plot\\n5. Add interactivity\\n6. Add styling\\n\\nNow let\'s complete each step.\\n\\n## Prepare the data\\n\\nBefore we are able to proceed, we need to prepare our dataset. For this example I have created some fake data. My data represents levels of skills for two persons.\\n\\n```javascript\\nconst initialData = [\\n  [\\n    { key: \'resilience\', value: 19 },\\n    { key: \'strength\', value: 6 },\\n    { key: \'adaptability\', value: 20 },\\n    { key: \'creativity\', value: 12 },\\n    { key: \'openness\', value: 1 },\\n    { key: \'confidence\', value: 11 },\\n  ],\\n  [\\n    { key: \'resilience\', value: 7 },\\n    { key: \'strength\', value: 18 },\\n    { key: \'adaptability\', value: 6 },\\n    { key: \'creativity\', value: 14 },\\n    { key: \'openness\', value: 17 },\\n    { key: \'confidence\', value: 14 },\\n  ],\\n];\\n```\\n\\n## Create the SVG element\\n\\nI create a file called `SimpleRadar.js` as my React component, and add an SVG element that will be used to render the radar plot. We need to define dimensions of our SVG.\\n\\n```javascript\\nconst dimensions = {\\n  width: 600,\\n  height: 600,\\n  margin: { top: 50, right: 60, bottom: 50, left: 60 },\\n};\\n\\nconst SimpleRadar = ({ data = initialData }) => {\\n  const { width, height, margin } = dimensions;\\n\\n  // bounding box dimensions\\n  const boundedDimensions = {\\n    width: dimensions.width - margin.left - margin.right,\\n    height: dimensions.height - margin.top - margin.bottom,\\n  };\\n\\n  boundedDimensions.radius = boundedDimensions.width / 2;\\n\\n  return (\\n    <div>\\n      <svg width={width} height={height}></svg>\\n    </div>\\n  );\\n};\\n```\\n\\nWe would like our radar plot to be in the center of the SVG, therefore, we\'d set our SVG `width` and `height` to be equal. The _bounding box_ that we create inside SVG, which basically contain all the data visualization elements must respect our SVG margins, to make sure the entire chart will displayed properly. Thus, we shift our bounding box so that `(0, 0)` point will be top-left of the bounding box. The figure below depicts the transformation.\\n\\n![grid line](/img/radar_svg_boundingbox.png)\\n\\nHowever, we will have some difficulties. Our radar chart is expected to be inside the bounding box, to be in the center of it to be exact. Therefore, selecting top-left of the bounding box as our `(0, 0)` point makes our math and all the calculations that we need to do for drawing circles, ticks, axes, etc., more difficult. Because all the drawings will be in respect to this point. _To make our math much easier later on_, we shift our bounding box in such a way that the point `(0, 0)` will shift to the center of the SVG. Now, we can place our visualization elements easily with respect to the center of radar plot circle.\\n\\n![grid line](/img/radar_svg_boundingbox_final.png)\\n\\n```javascript\\n// bounding box\\n<g\\n  transform={`translate(${margin.left + boundedDimensions.radius} ,${\\n    margin.top + boundedDimensions.radius\\n  } )`}\\n></g>\\n```\\n\\n## Define the scales\\n\\nAs our data shows, we have six skills (variables) that need to displayed on the radar chart. So, we need a _continuous_ scale with a `domain` of `[0,5]`.\\nRadar plot is _circular_, therefore, our scale\'s `range` must be `[0, 2 * Math.PI]`.\\n\\n```javascript\\n// This creates an array of [0, 1, 2, 3, 4, 5]\\nconst angleScaleDomain = d3.range(data[0].length + 1);\\n\\n// Accessor method to access `key` names from data\\nconst angleScaleDomainLabels = data[0].map((d) => d.key);\\n\\nconst angleScale = d3\\n  .scaleLinear()\\n  .domain(d3.extent(angleScaleDomain))\\n  .range([0, 2 * Math.PI]);\\n```\\n\\n:::info\\n\\nPlease note that we are using **radians** as javascript Math library has functions like `math.sin()` and `Math.cos()` that work with radians.\\n\\n:::\\n\\nWe can use our scale to find where to put six skills\' labels (`[\'resilience\', \'strength\', \'adaptability\', \'creativity\', \'openness\', \'confidence\']`) on the radar plot around the circle. Given our `angleScale`, we pass a number between 0 and 5 and it gives us the angle to place our label. Nevertheless, we need one more thing. We should be able to find a `[x, y]` position on the plot by giving an `angle`. How to do that? Answer is simple, we make use of our trigonometry knowledge.\\n\\nGiven an angle $\\\\theta$, we can calculate the `[x, y]` using the following formulas:\\n\\n![grid line](/img/radar_math_sin_cos.png)\\n\\nTherefore we have:\\n\\n$x= radius \\\\times \\\\cos(\\\\theta)$, and $y=radius \\\\times \\\\sin(\\\\theta)$\\n\\nIn order to draw elements at arbitrary _radii_ (e.g. tick values or skill labels), we add another variable `offset` to our function. Additionally, we rotate angles by -90 degrees or `-Math.PI/2` so the angle 0 begins at 12 O\'clock.\\n\\n```javascript\\nconst getCoordinatesForAngle = (angle, offset = 1) => {\\n  return [\\n    boundedDimensions.radius * Math.cos(angle - Math.PI / 2) * offset,\\n    boundedDimensions.radius * Math.sin(angle - Math.PI / 2) * offset,\\n  ];\\n};\\n```\\n\\nWe need another scale that I call it `radiusScale`, for our `value` field in our dataset, as each record in our dataset has `skill` and `value` attributes. Domain of `radiusScale` has to be `[min, max]` of `value` feature, and the range is the range will be `[0, radius]`.\\n\\n```javascript\\nlet allVals = [];\\ndata.map((array) => array.map((d) => allVals.push(d.value)));\\n\\nconst radiusScale = d3\\n  .scaleLinear()\\n  .domain([0, d3.max(allVals)])\\n  .range([0, boundedDimensions.radius])\\n  .nice();\\n```\\n\\nWe can use `radiusScale` to get ticks for our radar plot.\\n\\n```javascript\\nconst valueTicks = radiusScale.ticks(4);\\n```\\n\\n## Draw the radar plot\\n\\nNow that we have defined our scales, we only need to create a line generator to draw lines on the radar chart. We utilize `d3.lineRadial()` function, please see documentation [here](https://github.com/d3/d3-shape#lines). It\'s very similar to `d3.line()` except it accepts `angle()` and `radius()` methods.\\n\\n```javascript\\nconst radarLineGenerator = d3\\n  .lineRadial()\\n  .angle((d, i) => angleScale(i))\\n  .radius((d) => radiusScale(d.value))\\n  .curve(d3.curveCardinalClosed);\\n```\\n\\nWe are ready to create our radar plot. We start by drawing `grid lines` for our skills as well as skills\' labels. We have our labels, therefore, we simply iterate over each one and get its angle, then find `[x, y]` using our `getCoordinatesForAngle()` and draw `<line>` from the center of the circle. For drawing the labels, we would like them to be a little bit outside of the radar plot circle, therefore, we set our `offset` to be slightly bigger than 1. Here\'s the code:\\n\\n```javascript\\n{\\n  angleScaleDomainLabels.map((label, i) => {\\n    const angle = angleScale(i);\\n    const [x, y] = getCoordinatesForAngle(angle);\\n    const [labelX, labelY] = getCoordinatesForAngle(angle, 1.1);\\n    return (\\n      <g key={i} className=\\"grid\\">\\n        <line x2={x} y2={y} stroke=\\"#E5E2E0\\" className=\\"grid-line\\" />\\n        <text\\n          x={labelX}\\n          y={labelY}\\n          textAnchor={labelX < 0 ? \'end\' : labelX < 3 ? \'middle\' : \'start\'}\\n        >\\n          {label}\\n        </text>\\n      </g>\\n    );\\n  });\\n}\\n```\\n\\nThe figure below shows the output:\\n\\n![grid line](/img/radar_gridline.png)\\n\\nWe need to draw the ticks. For each tick value, we draw a `<circle>` with `r=radiusScale(tick)` and for tick label we create a `<text>` element and set `x` and `y` positions. I set the `x` value to be slightly to the right and `y` values be vertically drawn.\\n\\n```javascript\\n{\\n  valueTicks.reverse().map((tick, i) => (\\n    <g key={i} className=\\"grid\\">\\n      <circle\\n        // style={{ filter: \'url(#dropshadow)\' }}\\n        r={radiusScale(tick)}\\n        fill=\\"#fff\\"\\n        // fill=\\"#E5E2E0\\"\\n        stroke=\\"#E5E2E0\\"\\n        fillOpacity={0.9}\\n      />\\n      <text x={5} y={-radiusScale(tick)} dy=\\".3em\\">\\n        {tick}\\n      </text>\\n    </g>\\n  ));\\n}\\n```\\n\\n![radar ticks](/img/radar_ticks.png)\\nTo finish our drawing, we need to draw the lines using our `lineGenerator`. We have two series of records for two people, so we will draw two `path` elements.\\n\\n```javascript\\n<g>\\n   <path\\n     d={radarLineGenerator(data[0])}\\n     fill=\\"#137B80\\"\\n     stroke=\\"#137B80\\"\\n     strokeWidth=\\"2.5\\"\\n     fillOpacity=\\"0.1\\"\\n   />\\n </g>\\n <g>\\n   <path\\n     d={radarLineGenerator(data[1])}\\n     fill=\\"#E6842A\\"\\n     stroke=\\"#E6842A\\"\\n     strokeWidth=\\"2.5\\"\\n     fillOpacity=\\"0.1\\"\\n   />\\n </g>\\n```\\n\\nYou can see the radar plot in the image below.\\n\\n![grid line](/img/radar_simple.png)\\n\\nIt looks nice already! Nevertheless, Let\'s add more styling to that. I would like to add some shadow to my plot and each inner circle. To be able to do that, we cannot use CSS `box-shadow`, because it gives us a rectangular shadow, so it\'s not good for non-rectangular shapes. Instead, we will use the CSS `filter` property with `drop-shadow`. Another way is to define a SVG [filter](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter) to have lots of flexibility to control the shadow and opacity to give to `drop-shadow`. For this example, I\'ll go with the former option. I created a CSS file `styles.css` and added the following CSS rules:\\n\\n```css\\ngrid circle {\\n  filter: drop-shadow(0px 5px 100px rgba(146, 212, 238, 0.9));\\n  mix-blend-mode: multiply;\\n}\\n```\\n\\n![grid line](/img/radar_overflow.png)\\n\\nThe plot looks quite beautiful. However, you can see a rectangle around it that has clipped the shade of the blue color. It can be easily fixed by adding an `overflow: \'visible\'` property to the SVG element.\\n\\n```javascript\\n<svg\\n  width={width}\\n  height={height}\\n  style={{ backgroundColor: \'#fff\', overflow: \'visible\' }}\\n>\\n  // rest of the code\\n</svg>\\n```\\n\\n![grid line](/img/radar_pretty.png)\\n\\nBy changing the `drop-shadow` values, you\'ll get very pretty plots.\\n\\n![grid line](/img/radar_pretty_2.png)\\n\\nYou can find the code here at [Github repo](https://github.com/mallahyari/vis-react-d3)"},{"id":"add-tooltip","metadata":{"permalink":"/visualdecode/blog/add-tooltip","source":"@site/blog/2023-01-22-adding-tooltip.md","title":"How to add a tooltip to a line chart","description":"\x3c!--","date":"2023-01-22T00:00:00.000Z","formattedDate":"January 22, 2023","tags":[{"label":"tooltip","permalink":"/visualdecode/blog/tags/tooltip"},{"label":"react","permalink":"/visualdecode/blog/tags/react"},{"label":"d3","permalink":"/visualdecode/blog/tags/d-3"},{"label":"line chart","permalink":"/visualdecode/blog/tags/line-chart"}],"readingTime":6.49,"hasTruncateMarker":true,"authors":[{"name":"Mehdi Allahyari","title":"Principle Research Scientist","url":"https://github.com/mallahyari","imageURL":"https://github.com/mallahyari.png","key":"mehdi"}],"frontMatter":{"slug":"add-tooltip","title":"How to add a tooltip to a line chart","authors":["mehdi"],"tags":["tooltip","react","d3","line chart"]},"prevItem":{"title":"Designing Eye-catching Radar Plots with React and D3","permalink":"/visualdecode/blog/beautiful-radar-plot"},"nextItem":{"title":"Visualizing Data with Line Charts in React and D3","permalink":"/visualdecode/blog/linechart-visualization"}},"content":"\x3c!--\\nimport TOCInline from \'@theme/TOCInline\';\\n\\n<details>\\n<summary> Table of Contents</summary>\\n\\n<TOCInline toc={toc} />\\n</details> --\x3e\\n\\nCreating a tooltip for a line chart can be a great way to add interactivity and provide additional information to your data visualization. In this blog post, I will show you how to create a tooltip for a line chart using D3 and React.\\n\\n\x3c!--truncate--\x3e\\n\\n## Step 1: Set up the line chart\\n\\nThe first step is to set up the line chart. You can use any charting library to create your line chart. You can read my post [visualizing data with line chart](./2023-01-15-linechart.md) and generate the line chart.\\n\\n## Step 2: Create the tooltip\\n\\nThe next step is to create the tooltip. We can use third party libraries such as [react-tooltip](https://github.com/ReactTooltip/react-tooltip), yet again where will be the fun of it?! All jokes aside, our goal here is to learn how to create our own custom tooltip for our visualizations. Nevertheless, in future we will use some existing libraries. You can create a new `div` element for the tooltip and give it an initial position, such as `display: \'none\'`, to hide it initially. You can then use React state to keep track of whether or not the tooltip should be displayed.\\n\\nOur tooltip needs some basic CSS properties like initial positioning, background color, etc. I create a `styles.css` file and defined the following properties:\\n\\n```css\\n#wrapper {\\n  position: relative;\\n}\\ntooltip {\\n  opacity: 1;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  padding: 0.3em 1em;\\n  background: #fff;\\n  text-align: center;\\n  border: 1px solid #ddd;\\n  z-index: 10;\\n  transition: all 0.2s ease-out;\\n  /* Prevent tooltip from receiving the mouse events we will be implementing */\\n  pointer-events: none;\\n}\\n\\n/* Adds an arrow pointing down at the hovered bar */\\n.tooltip:before {\\n  content: \'\';\\n  position: absolute;\\n  bottom: 0;\\n  left: 50%;\\n  width: 12px;\\n  height: 12px;\\n  background: white;\\n  border: 1px solid #ddd;\\n  border-top-color: transparent;\\n  border-left-color: transparent;\\n  transform: translate(-50%, 50%) rotate(45deg);\\n  transform-origin: center center;\\n  z-index: 10;\\n}\\n```\\n\\nIn order for our toolip to work properly, it must have an absolute position (`position: absolute`) and its parent container (`div` with id of `wrapper`) needs to have a relative position (`position: relative`). `.tooltip:before` pseudo-selector will add an arrow pointing down at the hovered point. Also `pointer-events: none` prevents the tootip from stealing to mouse events as we\'ll add the events to our line and not the tooltip. The snippet below partially shows the `linechart.js` along with our tooltip component:\\n\\n```javascript\\n<div id=\\"wrapper\\">\\n  <svg width={width} height={height} style={{ backgroundColor: \'#F5F3F2\' }}>\\n    // line chart code\\n  </svg>\\n  <div className=\\"tooltip\\">\\n    <div>Date:</div>\\n    <div>Price:</div>\\n  </div>\\n</div>\\n```\\n\\nToolitp is positioned in the top left of our `wrapper` div.\\n![tooltip-initial](/img/tooltip-initial.png)\\n\\n## Step 3: Add event listeners\\n\\nTo make the tooltip interactive, you need to add event listeners to the line chart. You can use the `onMouseMove` and `onMouseLeave` events to detect when the user hovers over the line chart. However, instead of catching hover events for individual points of the line chart, we want to show a tooltip whenever a user is hovering anywhere on the chart. Therefore, we need to cover the entire bounding box of the line chart. To make that happen, we have to create a `<rect>` that spans our bounding box and add mouse event listeners to it.\\n\\n```javascript\\n<rect\\n  width={boundedDimensions.width}\\n  height={boundedDimensions.height}\\n  fill=\\"transparent\\"\\n  onMouseMove={(e) => handleMouseMove(e)}\\n  onMouseLeave={handleMouseLeave}\\n/>\\n```\\n\\nPlease note that we don\'t need to specify the `x` and `y` attributes since they both default to 0. Also we have to set `<rect>`\'s `fill` property to `transparent`, otherwise we will see a black rectangle covering the whole chart.\\n\\n## Step 4: Show the tooltip\\n\\nWhen the user hovers anywhere over the line chart, we can use React state to update the position and visibility of the tooltip.\\n\\n```javascript\\n// Tooltip data\\nconst [tooltipData, setTooltipData] = useState({});\\n\\n// Flag to control whether to show or hide tooltip\\nconst [showTooltip, setShowTooltip] = useState(false);\\n\\n// x, y postion of closest point for drawing a circle\\n// around the point on the chart\\nconst [xPos, setXPos] = useState(0);\\nconst [yPos, setYPos] = useState(0);\\n```\\n\\nAlthough we can use the `event.clientX` and `event.clientY` properties to get the current mouse position directly, we\'d rather use [d3.pointer()](https://github.com/d3/d3-selection/blob/main/README.md#pointer) to transform the event position to the local coordinate system of the element that received the event. And use that position to set the tooltip\'s position.\\n\\n```javascript\\nconst handleMouseMove = (e) => {\\n  const mouseXYPos = d3.pointer(e);\\n  console.log(mouseXYPos);\\n};\\n\\n// Example of mouse position as an [x, y] array in\\n// the console output while moving the mouse\\n[689, 284];\\n```\\n\\n## Step 5: Add the data to the tooltip\\n\\nWhen the user hovers over the line chart, we can use the data associated with that point to update the tooltip. We can use the `d3.bisector()` function to find the closest point on the line chart to the current mouse position and then use the data associated with that point to update the tooltip. To find the closes point, we can use the x position of the `mouseXYPos` point. Then using our `xScale.invert()` function, we convert from `range` (i.e. pixels) to the `domain` (i.e. dates in our dataset).\\n\\n```javascript\\nconst xPos = mouseXYPos[0];\\nconst hoveredDate = xScale.invert(xPos);\\n```\\n\\nNext, we have to find the closest data point, i.e. the data point with the _closest date_, in our dataset that this `hoveredDate`. We can define a function that computes the distance via some _comparator_ between two adjacent items. We run that for all the items in the dataset, and find the index of the item with least distance. However, d3 comes to save us by providing these many utility functions including one for this purpose. [d3.bisector(accessor/comparator)](https://github.com/d3/d3-array) returns a new bisector using the specified _accessor_ or _comparator_ function. In other words, it returns the insertion point for x in _array_ to maintain sorted order. If x is already present in array, the insertion point will be before (to the left of) or after (to the right) any existing entries depending on if we choose `bisectLeft` or `bisectRight`.\\n\\n```javascript\\nconst bisectDate = d3.bisector((d) => xAccessor(d)).right;\\nconst closestIndex = bisectDate(data, hoveredDate);\\n```\\n\\nWe have the index of the closest point, so we can easily\\n\\n- retrieve the corresponding data item\\n- calculate the position of the tooltip to be displayed\\n- update the tooltip data and React state\\n\\n```javascript\\nconst closestDataPoint = data[closestIndex];\\nconst closestXValue = xAccessor(closestDataPoint);\\nconst closestYValue = yAccessor(closestDataPoint);\\nconst newTooltipData = {\\n  data: closestDataPoint,\\n  x: xScale(closestXValue) + dimensions.margin.left,\\n  y: yScale(closestYValue),\\n};\\nsetTooltipData(newTooltipData);\\nsetShowTooltip(true);\\nsetXPos(() => xScale(closestXValue));\\nsetYPos(() => yScale(closestYValue));\\n```\\n\\nIn addition to the tooltip, I added a vertical line `<line>`, and a `<circle>` to make the toolip more readable.\\n\\n```javascript\\n  <circle\\n    cx={xPos}\\n    cy={yPos}\\n    r=\\"3\\"\\n    fill=\\"white\\"\\n    stroke=\\"#BD2D28\\"\\n    strokeWidth=\\"2\\"\\n    pointerEvents=\\"none\\"\\n  />\\n  <line\\n    x1={xPos}\\n    y1={0}\\n    x2={xPos}\\n    y2={boundedDimensions.height}\\n    stroke=\\"#0F8C79\\"\\n    strokeWidth=\\"2\\"\\n    strokeDasharray=\\"5,4\\"\\n    pointerEvents=\\"none\\"\\n  />\\n```\\n\\n![tooltip](/img/tooltip-final.png)\\n\\n## Step 6: Add styling\\n\\nWe can use CSS to style the tooltip and make it look more attractive. I simply added a few CSS properties in the `styles.css` to make the tooltip slightly more appealing.\\n\\n```css\\n.tooltip-info {\\n  font-size: 12px;\\n  text-align: left;\\n}\\n.tooltip p {\\n  margin-top: 5px;\\n  margin-bottom: 5px;\\n}\\n```\\n\\nAdditionally, I refactored the code a bit and created a separate component for the tooltip.\\n\\n```javascript\\nconst Tooltip = ({ tooltipData }) => {\\n  const { data } = tooltipData;\\n  return (\\n    <div\\n      className=\\"tooltip\\"\\n      style={{\\n        transform: `translate(calc(-50% + ${tooltipData.x}px), calc(-100% + ${tooltipData.y}px))`,\\n      }}\\n    >\\n      <div className=\\"tooltip-info\\">\\n        <p>\\n          <strong>Date: </strong>\\n          {data.Date}\\n        </p>\\n        <p>\\n          <strong>Price: </strong> {Number.parseFloat(data.Close).toFixed(2)}\\n        </p>\\n      </div>\\n    </div>\\n  );\\n};\\n```\\n\\nHere\'s our final tooltip:\\n![final tooltip](/img/linechart-tooltip.gif)\\n\\nIn summary, adding a tooltip to a line chart is a great way to make your data visualization more interactive and informative. With the help of React, you can easily create a tooltip that displays additional information when a user hovers over a specific point. You can find the code in this [Github repo](https://github.com/mallahyari/vis-react-d3)."},{"id":"linechart-visualization","metadata":{"permalink":"/visualdecode/blog/linechart-visualization","source":"@site/blog/2023-01-15-linechart.md","title":"Visualizing Data with Line Charts in React and D3","description":"\x3c!--","date":"2023-01-15T00:00:00.000Z","formattedDate":"January 15, 2023","tags":[{"label":"data visualization","permalink":"/visualdecode/blog/tags/data-visualization"},{"label":"react","permalink":"/visualdecode/blog/tags/react"},{"label":"d3","permalink":"/visualdecode/blog/tags/d-3"},{"label":"line chart","permalink":"/visualdecode/blog/tags/line-chart"}],"readingTime":11.18,"hasTruncateMarker":true,"authors":[{"name":"Mehdi Allahyari","title":"Principle Research Scientist","url":"https://github.com/mallahyari","imageURL":"https://github.com/mallahyari.png","key":"mehdi"}],"frontMatter":{"slug":"linechart-visualization","title":"Visualizing Data with Line Charts in React and D3","authors":["mehdi"],"tags":["data visualization","react","d3","line chart"],"hide_table_of_contents":false,"toc_min_heading_level":2,"toc_max_heading_level":5},"prevItem":{"title":"How to add a tooltip to a line chart","permalink":"/visualdecode/blog/add-tooltip"}},"content":"\x3c!--\\nimport TOCInline from \'@theme/TOCInline\';\\n\\n<details>\\n<summary> Table of Contents</summary>\\n\\n<TOCInline toc={toc} />\\n</details> --\x3e\\n\\nData visualization is an important aspect of making sense of large amounts of data. It allows us to quickly identify patterns and trends, and make informed decisions based on that information. React and D3.js are two powerful tools that can be used together to create powerful and interactive data visualizations. \x3c!--truncate--\x3e\\n\\nIn this blog post, we\'ll explore how to use React and D3.js to create data visualizations, and how they can be used together to create dynamic and interactive visualizations.\\n\\nFirst, let\'s take a look at D3.js. [D3.js](https://d3js.org/), which stands for Data-Driven Documents, is a JavaScript library that allows you to create data-driven documents, such as charts and graphs, using HTML, CSS, and SVG. It has a wide range of built-in functions and tools that can be used to create a wide range of different types of visualizations.\\n\\n[React](https://reactjs.org/), on the other hand, is a JavaScript library for building user interfaces. It allows you to create reusable components that can be easily integrated into your application. React\'s virtual DOM (Document Object Model) makes it easy to update and render changes to the UI, which is important when working with dynamic data.\\n\\nCombining React and D3.js could be notoriously tricky, since they both want to handle the DOM. Nevertheless, if done properly, it allows us to take advantage of the strengths of both libraries. while D3.js can handle the creation and manipulation of the visualizations themselves, we\'d rather use it for data manipulation and let React handle the application\'s state, visualization, and user interactions. This separation of concerns allows for a more maintainable and scalable codebase.\\n\\n## Set up a React project\\n\\nWhen creating a data visualization with React and D3.js, the first step is to set up a React project. You can use the create-react-app command to set up a new project, and then install D3.js using npm.\\n\\n```bash\\nnpx create-react-app my-app\\n```\\n\\nThis will create a new directory called \\"my-app\\" that contains a basic React project.\\nOnce you have your React project set up, the next step is to install D3.js. You can do this by running the following command in your project directory:\\n\\n```bash\\nnpm install d3\\n```\\n\\nOnce your project is set up, you can start creating your visualization. Here are the general steps for creating a visualization using D3.js:\\n\\n1. Collect and prepare your data: Before creating the visualization, you\'ll need to have your data ready. This means cleaning, formatting, and organizing the data as needed.\\n\\n2. Set up the SVG container: D3.js uses SVG (Scalable Vector Graphics) to create visualizations. This means that you\'ll need to create an SVG element in your HTML and set its size and dimensions.\\n\\n3. Create scales: D3.js uses scales to map data values to visual elements. You\'ll need to create a scale for each dimension of your data. For example, if you\'re creating a line chart, you\'ll need to create a scale for the x-axis and a scale for the y-axis.\\n\\n4. Create the visualization: Once you have your data, container, and scales set up, you can start creating the visualization itself. This can involve creating the elements that make up the visualization (e.g. lines, bars, circles) and binding the data to those elements.\\n\\n5. Add axis, labels and legends: Adding axis, labels and legends help to understand the data better and make it clear what the visualization represents.\\n\\n6. Add interactivity: D3.js allows you to add interactivity to your visualizations, such as hover effects and animations. You can use D3\'s built-in functions and events to add interactivity to your visualization. **We, however, use React for interactions.**\\n\\n7. Test and refine: Once you have your visualization set up, you\'ll want to test it and make any necessary adjustments. This can involve adjusting the scales, tweaking the visual elements, and adding or removing interactivity as needed.\\n\\nWe leave the interactivity to a separate blog post.\\n\\n## Set up line chart with React\\n\\nIn your project directory, create a new file called `LineChart.js` and add the following code:\\n\\n```javascript\\nimport React, { useRef, useEffect } from \'react\';\\nimport * as d3 from \'d3\';\\n\\nconst dimensions = {\\n  width: 600,\\n  height: 400,\\n  margin: { top: 30, right: 30, bottom: 40, left: 50 },\\n};\\n\\nconst LineChart = ({ data }) => {\\n  const boundedDimensions = {\\n    width: dimensions.width - margin.left - margin.right,\\n    height: dimensions.height - margin.top - margin.bottom,\\n  };\\n\\n  // 1. Access the data\\n\\n  // 2. Create scales\\n\\n  // 3. Draw visualization\\n\\n  // 4. Draw axis, labels, legends, etc\\n\\n  return <svg width={dimensions.width} height={dimensions.height}></svg>;\\n};\\n```\\n\\nInside our component we need to create a **SVG** element to be able to visualize the data in the browser. Therefore, we define our SVG element and set the `width` and `height` of it.\\n\\n### Collect and prepare the data\\n\\nThe dataset that I\'ll be using contains Apple stock prices from 2013 to 2018 that I got from [Observable](https://observablehq.com/@observablehq/sample-datasets#-aapl). In order to easily work with the data, I created a [Github Gist](https://gist.github.com/mallahyari/8d4f6a43c80154bdb391edbc3f156029) and uploaded csv file. Below is a screenshot of the data columns and values.\\n\\n![Apple csv sample](/img/apple_csv.png)\\n\\nWe\'ll be using the `Date` and `Close` cloumns for our line chart. There are several ways to read and load the dataset. We are going to utilize `d3.csv()` built-in function. It\'s simply a convenient method on top of Fetch API. For more information please see its documentation [here](https://devdocs.io/d3~7/).\\n\\n```javascript\\nd3.csv(url[([, accessor], callback)]);\\n```\\n\\nTo make the code more modularized, I have defined a custom hook that loads the dataset in the `App.js` file and passes it to `LineChart` component.\\n\\n```javascript\\nimport React, { useEffect, useState } from \'react\';\\nimport { csv } from \'d3\';\\nconst useData = () => {\\n  const [data, setData] = useState();\\n  useEffect(() => {\\n    csv(\\n      \'https://gist.githubusercontent.com/mallahyari/8d4f6a43c80154bdb391edbc3f156029/raw/26792b80dbabdd6371bc9ff10c17f9a090495649/apple_stock_price.csv\'\\n    ).then((dataset) => setData(dataset));\\n  }, []);\\n\\n  return data;\\n};\\n\\nexport default useData;\\n```\\n\\n### Set up SVG container\\n\\nWhen drawing a chart, we need two containers. First one is the main SVG that holds the entire chart, axes, data elements, labels, etc. We call this container, the `wrapper`. The second one (inner container) that contains our data elements and we call it `bounding box`. We, then, need to define dimensions for both containers.\\nImage below illustrates the wrapper SVG and bounding box containers.\\n\\nimport Figure from \'@site/src/components/Figure\'\\n\\n<Figure imageSrc=\'svg_wrapper.png\' caption=\'Chart dimensions\' />\\n\\n\x3c!-- <Figure imageSrc=\'img/svg_wrapper.png\' caption=\'Chart dimensions\' /> --\x3e\\n\\nWe define a dimension object that contains the size of the wrapper and all the margins. The margins give room for axes, ticks, labels, annotation, etc.\\n\\n```javascript\\n<svg width={width} height={height} style={{ border: \'1px solid black\' }}>\\n  <g transform={`translate(${margin.left},${margin.top})`}></g>\\n</svg>\\n```\\n\\nThe `<g>` element is our bounding box that contains and _groups_ data elements visualizations. We need to **shift** bounding box to respect our top and left margins, to make sure that our chart is inside our SVG element. The CSS `transform` property allows the `<g>` element to shift its content all at once.\\n\\n```javascript\\nconst dimensions = {\\n  width: 800,\\n  height: 400,\\n  margin: { top: 30, right: 30, bottom: 40, left: 60 },\\n};\\n```\\n\\n### Define data accessors\\n\\nWhen the data is available in our `LineChart` component, we need to access the metrics (i.e. columns) that we want to visualize.\\n\\n```javascript\\n// Define accessors\\nconst dateParser = d3.timeParse(\'%Y-%m-%d\');\\nconst xAccessor = (d) => dateParser(d.Date);\\nconst yAccessor = (d) => +d.Close;\\n```\\n\\nBoth the `Date` and `Close` columns are `string`, and also, I used `d3.timeParse` to parse the string and convert it to Javascript `date` object. You can check the documentation [here](https://github.com/d3/d3-time-format).\\n\\n### Create the scales\\n\\nIn D3.js, a scale is a function that maps data values to visual elements, such as pixels on a screen. Scales are used to translate the data into the coordinate system that is used by the SVG elements that make up the visualization.\\nD3.js provides several types of [scales](https://github.com/d3/d3-scale), including linear scales, time scales, and ordinal scales, and a few more. Each type of scale is designed to work with a specific type of data. For example, a linear scale can be used to map numerical data to a continuous range of values, such as pixels on a screen, while an ordinal scale can be used to map categorical data to a discrete range of values, such as colors. You can check this [link](https://observablehq.com/@observablehq/plot-cheatsheets-scales?collection=@observablehq/plot-cheatsheets) out to play with different scales in d3.\\n\\nLinear scale is one of the most common scales used in D3.js, it allows to map a continuous domain of data [min, max] to a continuous range of pixels [0, width]. For example, in a line chart, a linear scale can be used to map the x-axis data to the horizontal position of the line on the SVG, and the y-axis data to the vertical position of the line.\\n\\n<Figure imageSrc=\\"d3_scale.png\\" caption=\\"How scales map values\\" imageCredit=\\"https://observablehq.com/@observablehq/plot-cheatsheets-scales?collection=@observablehq/plot-cheatsheets\\" />\\n\\nWe need to create two scales: (i) a scale for x-axis to map date values of our dataset into the range of `[0, width]` of our bounding box; (ii) a scale that converts stock closing price into the range of `[0, height]`.\\n\\n```javascript\\n// Define Scales\\nconst xScale = d3\\n  .scaleTime()\\n  .domain(d3.extent(data, xAccessor))\\n  .range([0, boundedDimensions.width])\\n  .nice();\\n\\nconst yScale = d3\\n  .scaleLinear()\\n  .domain(d3.extent(data, yAccessor))\\n  .range([boundedDimensions.height, 0])\\n  .nice();\\n```\\n\\nThe reason that `yScale`\'s range is `[height, 0]` is that SVG y-values start from top to bottom so we want our range to begin at the top. Additionally, we used `d3.extent()` function from [d3-array](https://github.com/d3/d3-array) to find the minimum and maximum values for `date` and `close` columns.\\n\\n### Draw the line\\n\\nNow that we have defined our scales, we can draw the line and see the result. Thankfully, d3 save us again by providing us the tools and functions to create the line. We rely on [d3-shape](https://github.com/d3/d3-shape) to map our data to a line.\\n\\n```javascript\\n// Define line generator\\nconst lineGenerator = d3\\n  .line()\\n  .x((d) => xScale(xAccessor(d)))\\n  .y((d) => yScale(yAccessor(d)));\\n```\\n\\nThe line visualization is essentially a SVG `path` element that takes a `d` attribute to create a shape. Using `d3.line()` function generates the `d` string for us, which we can use in our `path` element.\\n\\n```javascript\\n<path\\n  d={lineGenerator(data)}\\n  className=\\"line-chart\\"\\n  fill=\\"none\\"\\n  stroke=\\"#E3BA22\\"\\n  strokeWidth=\\"2\\"\\n/>\\n```\\n\\nHere\'s our line chart:\\n![linechart](/img/linechart_01.png)\\n\\nCool! the line\'s drawn properly, however, there is no axis to help us understand the chart. Let\'s create axes for our line.\\n\\n### Draw the axes\\n\\nWe can use `d3.axisBottom()` and `d3.axisLeft()` functions from d3 API to create x and y axis respectively. Nevertheless, our goal is to create axes in React. So we have to write custom code to create the axis, ticks, and their format.\\n\\nOur axis needs:\\n\\n- A line that starts from 0 to width (for x axis) or height (y axis) of our chart.\\n- All the ticks with the labels\\n\\nOur scale\'s `tick([count])` method returns approximately count representative values from the scale\u2019s domain. If count is not specified, it defaults to 10. The specified _count_ is only a hint; the scale may return more or fewer values depending on the domain. Our `xScale.ticks()` method return 7 ticks:\\n\\n![xaxis](/img/xaxis_ticks.png#center)\\n\\nSince our tick values are dates, we can use `d3.timeFormat()` with a proper format to display the ticks on the axis. I used `d3.timeFormat(%b %Y)` to show only the month and year for ticks. You can see [d3-time-format](https://github.com/d3/d3-time-format) for complete formats information. Let\'s put together everything and create the React component for x axis:\\n\\n```javascript\\nconst AxisBottom = ({ width, height, xScale }) => {\\n  return (\\n    <g className=\\"axis xaxis\\" transform={`translate(0, ${height})`}>\\n      <line x1={0} x2={width} stroke=\\"currentColor\\" />\\n\\n      {xScale.ticks().map((tickvalue, i) => (\\n        <g key={i} transform={`translate(${xScale(tickvalue)},0)`}>\\n          <line y2={6} stroke=\\"currentColor\\" />\\n          <text\\n            // y=\\"15\\"\\n            dy=\\".71em\\"\\n            fill=\\"currentColor\\"\\n            style={{\\n              fontSize: \'10px\',\\n              textAnchor: \'middle\',\\n              transform: \'translateY(15px)\',\\n            }}\\n          >\\n            {timeFormat(\'%b %Y\')(tickvalue)}\\n          </text>\\n        </g>\\n      ))}\\n    </g>\\n  );\\n};\\n```\\n\\nSeveral points worth mentioning here. We grouped the entire axis into a `<g>` element so we can easily shift it because our `(0,0)` point is at top left. So we must move the x axis to the bottom. Then, we iterate on each tick value and create a tick line and a text label for it. To better organize ticks we put each tick into a separate `<g>` element too. And lastly, we can use `y` value or CSS `transform` to shift the text labels below the ticks for better readability.\\n\\nSimilarly, for y axis we\'ll have:\\n\\n```javascript\\nconst AxisLeft = ({ height, yScale }) => {\\n  return (\\n    <g className=\\"axis yaxis\\">\\n      <line x1={0} y2={height} stroke=\\"currentColor\\" />\\n\\n      {yScale.ticks().map((tickvalue, i) => (\\n        <g key={i} transform={`translate(0,${yScale(tickvalue)})`}>\\n          <line x2={-6} stroke=\\"currentColor\\" />\\n          <text\\n            // x={-15}\\n            dy={\'.32em\'}\\n            fill=\\"currentColor\\"\\n            style={{\\n              fontSize: \'10px\',\\n              textAnchor: \'end\',\\n              transform: \'translateX(-15px)\',\\n            }}\\n          >\\n            {tickvalue}\\n          </text>\\n        </g>\\n      ))}\\n    </g>\\n  );\\n};\\n```\\n\\nWe also define labels for our axes. The x axis label should be in the middle of the axis line (i.e. `width/2`) a bit further below tick values. Similarly, the y axis label should be in the middle (i.e. `height/2`), further to the left of the axis and needs to be rotated.\\n\\n```javascript\\n{/* X axis label */}\\n<text\\n  x={boundedDimensions.width / 2}\\n  y={35}\\n  className=\\"axis-label\\"\\n  transform={`translate(0, ${boundedDimensions.height})`}\\n  style={{\\n    fontSize: \'11px\',\\n    textAnchor: \'end\',\\n  }}\\n>\\n  {xAxisLabel}\\n\\n{/* Y axis label */}\\n<text\\n  textAnchor=\\"middle\\"\\n  className=\\"axis-label\\"\\n  transform={`translate(-35,${\\n    boundedDimensions.height / 2\\n  }) rotate(-90) `}\\n  style={{\\n    fontSize: \'11px\',\\n  }}\\n>\\n  {yAxisLabel}\\n</text>\\n```\\n\\nNot to mention that I added some CSS properties to the `line` and `text` elements to make them more apealing to the eyes.\\n\\nHere\'s the final result:\\n![line chart](/img/line_chart.png)\\n\\nYou can find the code at this [Github repo](https://github.com/mallahyari/vis-react-d3)."}]}')}}]);